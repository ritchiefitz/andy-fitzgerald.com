<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dave: Warriors & Wizards</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #87CEEB;
        }

        /* UI Layers */
        #ui-layer,
        #title-screen,
        #map-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* HUD */
        #hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 0 #000;
            user-select: none;
        }

        #stats-container {
            display: flex;
            gap: 20px;
        }

        #targets-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .target-badge {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            opacity: 0.4;
            transition: all 0.3s ease;
        }

        .target-badge.found {
            opacity: 1;
            box-shadow: 0 0 15px white;
            transform: scale(1.2);
        }

        .bg-red {
            background-color: #ff3333;
        }

        .bg-blue {
            background-color: #3333ff;
        }

        .bg-yellow {
            background-color: #ffff33;
        }

        .bg-green {
            background-color: #33ff33;
        }

        #health-display {
            color: #ff4444;
            font-size: 28px;
        }

        #coin-display {
            color: #FFD700;
            font-size: 28px;
        }

        #message-area {
            text-align: center;
            margin-bottom: 20%;
            font-size: 24px;
            font-weight: bold;
            color: #FFF176;
            text-shadow: 2px 2px 4px black;
            height: 40px;
            transition: opacity 0.5s;
        }

        /* Title Screen, Map & Shop */
        #title-screen,
        #map-screen {
            background: rgba(0, 0, 0, 0.85);
            pointer-events: auto;
            align-items: center;
            justify-content: center;
            z-index: 20;
            overflow-y: auto;
        }

        #title-content,
        #map-content {
            text-align: center;
            color: white;
            max-width: 800px;
            width: 90%;
        }

        h1 {
            font-size: 60px;
            color: #FFD700;
            text-shadow: 4px 4px 0 #000;
            margin-bottom: 10px;
        }

        h2 {
            font-size: 30px;
            margin-bottom: 20px;
            color: #ddd;
        }

        .btn-group {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            padding: 15px 30px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 5px #2E7D32;
            transition: transform 0.1s;
            font-weight: bold;
            min-width: 150px;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 1px #2E7D32;
        }

        button.btn-mode {
            background: #2196F3;
            box-shadow: 0 5px #1565C0;
        }

        button.btn-mode:hover {
            background: #1976D2;
        }

        button.btn-shop {
            background: #FF9800;
            box-shadow: 0 5px #F57C00;
        }

        button.btn-level {
            background: #555;
            box-shadow: none;
            cursor: not-allowed;
            opacity: 0.6;
        }

        button.btn-level.unlocked {
            background: #4CAF50;
            cursor: pointer;
            opacity: 1;
            box-shadow: 0 5px #2E7D32;
        }

        button.btn-back {
            background: #d32f2f;
        }

        /* Shop Grid */
        #shop-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            display: none;
            /* Hidden by default */
        }

        .shop-category {
            margin-bottom: 20px;
        }

        .shop-category h3 {
            text-align: left;
            border-bottom: 1px solid #555;
            margin-bottom: 10px;
        }

        .shop-items {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .shop-item {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid #555;
            width: 100px;
            text-align: center;
        }

        .shop-item:hover {
            background: #444;
        }

        .shop-item.equipped {
            border-color: #4CAF50;
            background: #2E3B2F;
        }

        .shop-item.locked {
            opacity: 0.5;
        }

        .price-tag {
            color: #FFD700;
            font-size: 14px;
            margin-top: 5px;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            /* Hidden initially */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            pointer-events: auto;
            z-index: 15;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>

    <!-- HUD -->
    <div id="ui-layer" class="hidden">
        <div id="hud">
            <div id="stats-container">
                <div id="timer">Time: 02:00</div>
                <div id="health-display">♥♥♥♥♥</div>
                <div id="coin-display">Coins: 0</div>
            </div>
            <div id="targets-container">
                <span>Find: </span>
                <div id="badge-red" class="target-badge bg-red"></div>
                <div id="badge-blue" class="target-badge bg-blue"></div>
                <div id="badge-yellow" class="target-badge bg-yellow"></div>
                <div id="badge-green" class="target-badge bg-green"></div>
            </div>
        </div>
        <div id="message-area"></div>
    </div>

    <!-- Title Screen -->
    <div id="title-screen">
        <div id="title-content">
            <h1>Dave: Warriors & Wizards</h1>
            <h2 id="bank-display">Total Coins: 0</h2>

            <div class="btn-group">
                <button class="btn-mode" onclick="showMap()">Story Mode</button>
                <button class="btn-mode" onclick="startCoinRush()">Coin Rush</button>
                <button class="btn-shop" onclick="toggleShop()">Shop</button>
            </div>

            <div id="shop-container">
                <h2>Dave's Armory</h2>
                <div id="shop-list"></div>
                <button onclick="toggleShop()" style="margin-top: 10px; background: #555;">Close Shop</button>
            </div>
        </div>
    </div>

    <!-- Map Screen -->
    <div id="map-screen" class="hidden">
        <div id="map-content">
            <h1>Select Level</h1>
            <p>Green Dave is waiting to help you!</p>
            <div class="btn-group">
                <button id="lvl-1-btn" class="btn-level" onclick="startStoryLevel(1)">Level 1<br><small>Warriors
                        Only</small></button>
                <button id="lvl-2-btn" class="btn-level" onclick="startStoryLevel(2)">Level 2<br><small>+
                        Archers</small></button>
                <button id="lvl-3-btn" class="btn-level" onclick="startStoryLevel(3)">Level 3<br><small>+ Evil
                        Dave</small></button>
            </div>
            <button class="btn-back" onclick="returnToTitle()">Back</button>
        </div>
    </div>

    <!-- Game Over Overlay -->
    <div id="overlay">
        <h1 id="overlay-title">Game Over</h1>
        <p id="overlay-desc"></p>
        <button id="return-btn" onclick="returnToTitle()">Return to Title</button>
        <button id="next-level-btn" class="hidden" onclick="nextLevel()">Next Level</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Configuration ---
        const CONFIG = {
            mapWidth: 120, mapHeight: 120, riverWidth: 14, riverZ1: -25, riverZ2: 25,
            bridgeWidth: 10, playerSpeed: 15, jumpForce: 15, gravity: 30,
            totalTimeStory: 120, totalTimeRush: 60,
            enemyRange: 40, chaseRange: 30, warriorSpeed: 7, fireballSpeed: 20, arrowSpeed: 35, evilDaveSpeed: 9,
            attackRange: 5, attackCooldown: 0.5
        };

        const LEVELS = [
            { id: 1, name: "Warrior's Field", enemies: ['warrior'], count: 8, hasEvilDave: false },
            { id: 2, name: "Archer's River", enemies: ['warrior', 'archer'], count: 12, hasEvilDave: false },
            { id: 3, name: "Evil Dave's Lair", enemies: ['warrior', 'archer', 'wizard'], count: 15, hasEvilDave: true }
        ];

        // --- Shop Data ---
        const ITEMS = {
            shirts: [
                { id: 'grey_shirt', name: 'Grey Shirt', price: 0, color: 0x333333, type: 'shirt' },
                { id: 'red_shirt', name: 'Red T-Shirt', price: 50, color: 0xAA0000, type: 'shirt' },
                { id: 'blue_shirt', name: 'Blue Hoodie', price: 50, color: 0x0000AA, type: 'shirt' },
                { id: 'gold_armor', name: 'Gold Armor', price: 200, color: 0xFFD700, type: 'shirt' }
            ],
            pants: [
                { id: 'navy_pants', name: 'Navy Pants', price: 0, color: 0x000080, type: 'pants' },
                { id: 'jeans', name: 'Blue Jeans', price: 50, color: 0x4444FF, type: 'pants' },
                { id: 'camo', name: 'Camo Pants', price: 100, color: 0x3B5323, type: 'pants' }
            ],
            hats: [
                { id: 'no_hat', name: 'No Hat', price: 0, color: null, type: 'hat' },
                { id: 'cap', name: 'Red Cap', price: 75, color: 0xFF0000, type: 'hat' },
                { id: 'tophat', name: 'Top Hat', price: 150, color: 0x111111, type: 'hat' },
                { id: 'crown', name: 'Crown', price: 500, color: 0xFFD700, type: 'hat' }
            ],
            swords: [
                { id: 'iron_sword', name: 'Iron Sword', price: 0, color: 0xDDDDDD, type: 'sword' },
                { id: 'gold_sword', name: 'Gold Sword', price: 200, color: 0xFFD700, type: 'sword' },
                { id: 'laser_sword', name: 'Laser Blade', price: 400, color: 0x00FF00, type: 'sword' }
            ]
        };

        // --- Sound Manager ---
        const SoundManager = {
            ctx: null,
            init: function () {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            play: function (type) {
                if (!this.ctx) this.init();
                if (this.ctx.state === 'suspended') this.ctx.resume();

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                const now = this.ctx.currentTime;

                if (type === 'jump') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.linearRampToValueAtTime(300, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                } else if (type === 'coin') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(1000, now);
                    osc.frequency.setValueAtTime(1500, now + 0.05);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                } else if (type === 'attack') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.15);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.15);
                    osc.start(now); osc.stop(now + 0.15);
                } else if (type === 'hit') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.linearRampToValueAtTime(20, now + 0.2);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                } else if (type === 'win') {
                    this.playTone(523.25, now, 0.1);
                    this.playTone(659.25, now + 0.1, 0.1);
                    this.playTone(783.99, now + 0.2, 0.3);
                } else if (type === 'lose') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.linearRampToValueAtTime(50, now + 0.5);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.5);
                    osc.start(now); osc.stop(now + 0.5);
                }
            },
            playTone: function (freq, time, dur) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, time);
                gain.gain.setValueAtTime(0.05, time);
                gain.gain.linearRampToValueAtTime(0, time + dur);
                osc.start(time); osc.stop(time + dur);
            }
        };

        // --- State ---
        let gameState = 'TITLE';
        let gameMode = 'story';
        let currentLevel = 1;

        let saveData = JSON.parse(localStorage.getItem('daveSave')) || {
            coins: 0,
            unlockedLevel: 1,
            owned: ['grey_shirt', 'navy_pants', 'no_hat', 'iron_sword'],
            equipped: { shirt: 'grey_shirt', pants: 'navy_pants', hat: 'no_hat', sword: 'iron_sword', shoes: 'brown_shoes', shield: 'wood_shield' }
        };

        // Globals
        let scene, camera, renderer, clock;
        let player = { velocity: new THREE.Vector3(), onGround: false, isCrouching: false, canAttack: true };
        let playerMesh, playerArmGroup;
        let obstacles = [], npcs = [], enemies = [], projectiles = [], coins = [];
        let timeRemaining, playerHealth, timerInterval;
        let targetsFound = { red: false, blue: false, yellow: false, green: false };
        let sessionCoins = 0;
        let msgTimeout;

        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false, attack: false };

        const uiLayer = document.getElementById('ui-layer');
        const titleScreen = document.getElementById('title-screen');
        const mapScreen = document.getElementById('map-screen');
        const overlay = document.getElementById('overlay');
        const bankDisplay = document.getElementById('bank-display');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const returnBtn = document.getElementById('return-btn');

        // --- Init ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            window.addEventListener('keydown', (e) => handleKey(e, true));
            window.addEventListener('keyup', (e) => handleKey(e, false));
            window.addEventListener('mousedown', () => { if (gameState === 'PLAYING') keys.attack = true; });
            window.addEventListener('resize', onWindowResize);

            updateShopUI();
            renderTitleBackground();
            animate();
        }

        function saveGame() {
            localStorage.setItem('daveSave', JSON.stringify(saveData));
            bankDisplay.textContent = `Total Coins: ${saveData.coins}`;
            updateShopUI();
        }

        function handleKey(e, isDown) {
            const key = e.key.toLowerCase();
            if (key === 'w' || key === 'arrowup') keys.w = isDown;
            if (key === 'a' || key === 'arrowleft') keys.a = isDown;
            if (key === 's' || key === 'arrowdown') keys.s = isDown;
            if (key === 'd' || key === 'arrowright') keys.d = isDown;
            if (key === ' ') keys.space = isDown;
            if (key === 'shift' || key === 'c') keys.shift = isDown;
            if (key === '/' || key === '?') keys.attack = isDown;
        }

        // --- Logic: Modes & Flow ---

        function showMap() {
            SoundManager.init();
            titleScreen.classList.add('hidden');
            mapScreen.classList.remove('hidden');

            for (let i = 1; i <= 3; i++) {
                const btn = document.getElementById(`lvl-${i}-btn`);
                if (i <= saveData.unlockedLevel) {
                    btn.classList.add('unlocked');
                    btn.onclick = () => startStoryLevel(i);
                } else {
                    btn.classList.remove('unlocked');
                    btn.onclick = null;
                }
            }
        }

        function startStoryLevel(lvl) {
            currentLevel = lvl;
            gameMode = 'story';
            startGame();
        }

        function startCoinRush() {
            SoundManager.init();
            gameMode = 'rush';
            startGame();
        }

        function startGame() {
            gameState = 'PLAYING';
            titleScreen.classList.add('hidden');
            mapScreen.classList.add('hidden');
            uiLayer.classList.remove('hidden');
            overlay.style.display = 'none';

            sessionCoins = 0;
            playerHealth = 5;
            timeRemaining = (gameMode === 'rush') ? CONFIG.totalTimeRush : CONFIG.totalTimeStory;
            targetsFound = { red: false, blue: false, yellow: false, green: false };

            document.getElementById('health-display').textContent = "♥♥♥♥♥";
            document.getElementById('coin-display').textContent = "Coins: 0";

            const targetsDiv = document.getElementById('targets-container');
            if (gameMode === 'rush') targetsDiv.classList.add('hidden');
            else {
                targetsDiv.classList.remove('hidden');
                ['red', 'blue', 'yellow', 'green'].forEach(c => {
                    document.getElementById(`badge-${c}`).className = `target-badge bg-${c}`;
                });
            }

            createWorld();

            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(gameTick, 1000);
        }

        function returnToTitle() {
            gameState = 'TITLE';
            overlay.style.display = 'none';
            uiLayer.classList.add('hidden');
            mapScreen.classList.add('hidden');
            titleScreen.classList.remove('hidden');
            renderTitleBackground();
            saveGame();
        }

        function toggleShop() {
            SoundManager.init();
            const shop = document.getElementById('shop-container');
            shop.style.display = (shop.style.display === 'block') ? 'none' : 'block';
        }

        function gameTick() {
            if (gameState !== 'PLAYING') return;
            timeRemaining--;
            let mins = Math.floor(timeRemaining / 60).toString().padStart(2, '0');
            let secs = (timeRemaining % 60).toString().padStart(2, '0');
            document.getElementById('timer').textContent = `Time: ${mins}:${secs}`;

            if (timeRemaining <= 0) {
                if (gameMode === 'rush') {
                    endGame(true, `Time's Up! You collected ${sessionCoins} Coins!`);
                } else {
                    SoundManager.play('lose');
                    endGame(false, "Time's up! You didn't find everyone.");
                }
            }
        }

        function nextLevel() {
            if (currentLevel < 3) {
                startStoryLevel(currentLevel + 1);
            } else {
                returnToTitle();
            }
        }

        function endGame(won, message) {
            gameState = 'GAMEOVER';
            SoundManager.play(won ? 'win' : 'lose');
            clearInterval(timerInterval);
            saveData.coins += sessionCoins;

            if (won && gameMode === 'story') {
                if (currentLevel === saveData.unlockedLevel && currentLevel < 3) {
                    saveData.unlockedLevel++;
                }
                nextLevelBtn.classList.remove('hidden');
                if (currentLevel === 3) nextLevelBtn.textContent = "Finish Game";
                else nextLevelBtn.textContent = "Next Level";

                returnBtn.classList.add('hidden');
            } else {
                nextLevelBtn.classList.add('hidden');
                returnBtn.classList.remove('hidden');
            }

            saveGame();

            const title = document.getElementById('overlay-title');
            const desc = document.getElementById('overlay-desc');

            title.textContent = won ? "Level Complete!" : "Game Over";
            if (won && gameMode === 'story' && currentLevel === 3) title.textContent = "YOU BEAT THE GAME!";
            if (gameMode === 'rush') title.textContent = "Run Finished";

            desc.innerHTML = message + `<br>Total Earned: ${sessionCoins} Coins`;
            overlay.style.display = 'flex';
        }

        // --- World Generation ---

        function renderTitleBackground() {
            while (scene.children.length > 0) { scene.remove(scene.children[0]); }
            const amb = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(amb);
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x4CAF50 }));
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            createPlayer();
            playerMesh.position.set(0, 0, 0);
            playerMesh.scale.set(2, 2, 2);
        }

        function createWorld() {
            while (scene.children.length > 0) { scene.remove(scene.children[0]); }
            obstacles = []; npcs = []; enemies = []; projectiles = []; coins = [];

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -70; dirLight.shadow.camera.right = 70;
            dirLight.shadow.camera.top = 70; dirLight.shadow.camera.bottom = -70;
            dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            const ground = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.mapWidth, CONFIG.mapHeight), new THREE.MeshStandardMaterial({ color: 0x4CAF50 }));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const riverGeo = new THREE.PlaneGeometry(CONFIG.mapWidth, CONFIG.riverWidth);
            const riverMat = new THREE.MeshStandardMaterial({ color: 0x2196F3, roughness: 0.1 });
            const r1 = new THREE.Mesh(riverGeo, riverMat); r1.rotation.x = -Math.PI / 2; r1.position.set(0, 0.05, CONFIG.riverZ1); scene.add(r1);
            const r2 = new THREE.Mesh(riverGeo, riverMat); r2.rotation.x = -Math.PI / 2; r2.position.set(0, 0.05, CONFIG.riverZ2); scene.add(r2);

            createBridge(CONFIG.riverZ1);
            createBridge(CONFIG.riverZ2);

            createPlayer();

            for (let i = 0; i < 60; i++) {
                let pos = getRandomPos();
                if (pos) Math.random() > 0.4 ? createTree(pos.x, pos.z) : createHouse(pos.x, pos.z);
            }

            for (let i = 0; i < 50; i++) {
                let pos = getRandomPos();
                if (pos) spawnCoin(pos.x, pos.z);
            }

            spawnNPC(0xff3333, 'Red', true);
            spawnNPC(0x3333ff, 'Blue', true);
            spawnNPC(0xffff33, 'Yellow', true);
            spawnNPC(0x33ff33, 'Green', true);

            const colors = [0xFFA500, 0x800080, 0x006400, 0xFFC0CB, 0xA52A2A];
            for (let i = 0; i < 15; i++) {
                let pos = getRandomPos();
                if (pos) spawnNPC(colors[Math.floor(Math.random() * colors.length)], 'Stranger', false, pos);
            }

            let levelConfig = LEVELS.find(l => l.id === currentLevel);
            if (gameMode === 'rush') levelConfig = LEVELS[2];

            for (let i = 0; i < levelConfig.count; i++) {
                let type = levelConfig.enemies[Math.floor(Math.random() * levelConfig.enemies.length)];
                spawnEnemy(type);
            }

            if (levelConfig.hasEvilDave || gameMode === 'rush') {
                spawnEvilDave();
            }

            spawnGiantFriend();
        }

        function getRandomPos() {
            for (let i = 0; i < 10; i++) {
                let x = (Math.random() * CONFIG.mapWidth) - CONFIG.mapWidth / 2;
                let z = (Math.random() * CONFIG.mapHeight) - CONFIG.mapHeight / 2;
                if (Math.abs(z - CONFIG.riverZ1) < CONFIG.riverWidth / 2 + 3) continue;
                if (Math.abs(z - CONFIG.riverZ2) < CONFIG.riverWidth / 2 + 3) continue;
                if (Math.abs(x) < 10 && z > 20) continue;

                let collision = false;
                for (let obs of obstacles) {
                    if (Math.hypot(x - obs.x, z - obs.z) < obs.radius + 2) collision = true;
                }
                if (!collision) return { x, z };
            }
            return null;
        }

        // --- Entities ---

        function spawnCoin(x, z) {
            const geo = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 16);
            const mat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8, roughness: 0.2 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = Math.PI / 2;
            mesh.rotation.z = Math.PI / 2;
            mesh.position.set(x, 1, z);
            scene.add(mesh);
            coins.push({ mesh: mesh, x: x, z: z });
        }

        function createBridge(z) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.bridgeWidth, 0.5, CONFIG.riverWidth + 4), new THREE.MeshStandardMaterial({ color: 0x8D6E63 }));
            b.position.set(0, 0.3, z); scene.add(b);
        }

        function createPlayer() {
            const group = new THREE.Group();

            const shirtItem = ITEMS.shirts.find(i => i.id === saveData.equipped.shirt) || ITEMS.shirts[0];
            const pantsItem = ITEMS.pants.find(i => i.id === saveData.equipped.pants) || ITEMS.pants[0];
            const hatItem = ITEMS.hats.find(i => i.id === saveData.equipped.hat) || ITEMS.hats[0];
            const swordItem = ITEMS.swords.find(i => i.id === saveData.equipped.sword) || ITEMS.swords[0];

            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.5, 0.8), new THREE.MeshStandardMaterial({ color: shirtItem.color }));
            body.position.y = 1.5;
            body.castShadow = true;
            group.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 12), new THREE.MeshStandardMaterial({ color: 0xFFCCAA }));
            head.position.y = 2.6;
            group.add(head);

            if (hatItem.id !== 'no_hat') {
                let hatGeo;
                if (hatItem.id === 'crown') hatGeo = new THREE.CylinderGeometry(0.6, 0.5, 0.4, 8);
                else if (hatItem.id === 'tophat') hatGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 12);
                else hatGeo = new THREE.ConeGeometry(0.6, 0.5, 12);

                const hat = new THREE.Mesh(hatGeo, new THREE.MeshStandardMaterial({ color: hatItem.color }));
                hat.position.y = 3.1;
                group.add(hat);
            }

            const armGeo = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const armMat = new THREE.MeshStandardMaterial({ color: shirtItem.color });
            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(-0.8, 1.8, 0);

            const shield = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.1, 16), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            shield.position.set(-0.3, -0.3, 0.3); shield.rotation.x = Math.PI / 2; shield.rotation.z = Math.PI / 4;
            leftArm.add(shield);
            group.add(leftArm);

            playerArmGroup = new THREE.Group();
            playerArmGroup.position.set(0.8, 2.3, 0);
            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(0, -0.5, 0);
            playerArmGroup.add(rightArm);

            const sCol = swordItem.color;
            const sBlade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 0.3), new THREE.MeshStandardMaterial({ color: sCol }));
            sBlade.position.set(0, -1.2, 1.0); sBlade.rotation.x = Math.PI / 2;
            playerArmGroup.add(sBlade);
            group.add(playerArmGroup);

            const legGeo = new THREE.BoxGeometry(0.4, 0.8, 0.4);
            const legMat = new THREE.MeshStandardMaterial({ color: pantsItem.color });
            const l1 = new THREE.Mesh(legGeo, legMat); l1.position.set(-0.3, 0.4, 0); group.add(l1);
            const l2 = new THREE.Mesh(legGeo, legMat); l2.position.set(0.3, 0.4, 0); group.add(l2);

            const fMat = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
            const f1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.6), fMat); f1.position.set(-0.3, 0.1, 0.1); group.add(f1);
            const f2 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.6), fMat); f2.position.set(0.3, 0.1, 0.1); group.add(f2);

            group.position.set(0, 0, 50);
            scene.add(group);
            playerMesh = group;
        }

        function createTree(x, z) {
            const g = new THREE.Group();
            const t = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.6, 2.5, 6), new THREE.MeshStandardMaterial({ color: 0x5D4037 }));
            t.position.y = 1.25; g.add(t);
            const l = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 8), new THREE.MeshStandardMaterial({ color: 0x2E7D32 }));
            l.position.y = 4; g.add(l);
            g.position.set(x, 0, z); scene.add(g);
            obstacles.push({ x: x, z: z, radius: 1.5 });
        }

        function createHouse(x, z) {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 4), new THREE.MeshStandardMaterial({ color: 0xEFEBE9 }));
            b.position.y = 1.5; g.add(b);
            const r = new THREE.Mesh(new THREE.ConeGeometry(3.5, 2, 4), new THREE.MeshStandardMaterial({ color: 0xbf360c }));
            r.position.y = 4; r.rotation.y = Math.PI / 4; g.add(r);
            g.position.set(x, 0, z); scene.add(g);
            obstacles.push({ x: x, z: z, radius: 3 });
        }

        function spawnNPC(color, name, isTarget, pos = null) {
            const g = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const b = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 2, 12), mat); b.position.y = 1; g.add(b);
            const h = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 12), new THREE.MeshStandardMaterial({ color: 0xFFCCAA })); h.position.y = 2.2; g.add(h);

            const aGeo = new THREE.BoxGeometry(0.3, 1.0, 0.3);
            const lA = new THREE.Mesh(aGeo, mat); lA.position.set(-0.7, 1.3, 0); g.add(lA);
            const rA = new THREE.Mesh(aGeo, mat); rA.position.set(0.7, 1.3, 0); g.add(rA);

            if (isTarget) {
                const hat = new THREE.Mesh(new THREE.ConeGeometry(0.7, 0.8, 8), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
                hat.position.y = 2.8; g.add(hat);
                g.scale.set(2, 2, 2);
            }

            if (!pos) pos = getRandomPos();
            if (pos) {
                g.position.set(pos.x, 0, pos.z);
                scene.add(g);
                npcs.push({
                    mesh: g, name: name, isTarget: isTarget, collected: false, x: pos.x, z: pos.z, radius: isTarget ? 3 : 1.5,
                    moveDir: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(), moveTimer: 2, speed: 4
                });
            }
        }

        function spawnEnemy(type) {
            const g = new THREE.Group();

            const b = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 2, 12), new THREE.MeshStandardMaterial({ color: 0x333333 })); b.position.y = 1; g.add(b);
            const h = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 12), new THREE.MeshStandardMaterial({ color: 0xFFCCAA })); h.position.y = 2.2; g.add(h);

            if (type === 'wizard') {
                b.material.color.set(0x222222);
                const hood = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 8, 0, 6.28, 0, 1.57), new THREE.MeshStandardMaterial({ color: 0x111111 })); hood.position.y = 2.5; g.add(hood);
                // Staff
                const staff = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 3, 6), new THREE.MeshStandardMaterial({ color: 0x5D4037 })); staff.position.set(0.8, 1.5, 0); staff.rotation.z = 0.8; g.add(staff);
            } else if (type === 'archer') {
                b.material.color.set(0x2E8B57);
                // Quiver
                const q = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.5, 0.4), new THREE.MeshStandardMaterial({ color: 0x8B4513 })); q.position.set(0, 1.5, -0.6); g.add(q);
                // Bow
                const bow = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.08, 8, 16, 3.14), new THREE.MeshStandardMaterial({ color: 0x8B4513 })); bow.position.set(0, 1.5, 0.5); bow.rotation.x = 1.57; bow.rotation.y = 1.57; g.add(bow);
            } else {
                b.material.color.set(0x708090);
                const s = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 0.1), new THREE.MeshStandardMaterial({ color: 0xC0C0C0 })); s.position.set(0.6, 1.2, 0.5); s.rotation.x = 0.7; g.add(s);
                // Shield
                const sh = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 0.2, 16), new THREE.MeshStandardMaterial({ color: 0x8B4513 })); sh.position.set(-0.8, 1.5, 0.5); sh.rotation.z = 1.57; g.add(sh);
            }

            const e = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.1, 0.1), new THREE.MeshBasicMaterial({ color: 0xff0000 })); e.position.set(-0.2, 2.3, 0.35); g.add(e);
            const e2 = e.clone(); e2.position.set(0.2, 2.3, 0.35); g.add(e2);

            // Arms
            const armG = new THREE.BoxGeometry(0.3, 1.0, 0.3);
            const armM = new THREE.MeshStandardMaterial({ color: b.material.color });
            const lA = new THREE.Mesh(armG, armM); lA.position.set(-0.7, 1.3, 0); g.add(lA);
            const rA = new THREE.Mesh(armG, armM); rA.position.set(0.7, 1.3, 0); g.add(rA);

            // Legs
            const lG = new THREE.BoxGeometry(0.4, 0.8, 0.4); const lM = new THREE.MeshStandardMaterial({ color: 0x000080 });
            const l1 = new THREE.Mesh(lG, lM); l1.position.set(-0.3, 0.4, 0); g.add(l1);
            const l2 = new THREE.Mesh(lG, lM); l2.position.set(0.3, 0.4, 0); g.add(l2);

            let pos = getRandomPos();
            if (pos) {
                g.position.set(pos.x, 0, pos.z); scene.add(g);
                enemies.push({ mesh: g, type: type, hp: 1, x: pos.x, z: pos.z, cooldown: Math.random() * 2 });
            }
        }

        function spawnEvilDave() {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.5, 0.8), new THREE.MeshStandardMaterial({ color: 0x333333 })); b.position.y = 1.5; g.add(b);
            const h = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 12), new THREE.MeshStandardMaterial({ color: 0xFF0000 })); h.position.y = 2.6; g.add(h);

            const armG = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const armM = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const lA = new THREE.Mesh(armG, armM); lA.position.set(-0.8, 1.8, 0); g.add(lA);
            const rA = new THREE.Mesh(armG, armM); rA.position.set(0.8, 1.8, 0); g.add(rA);

            const lG = new THREE.BoxGeometry(0.4, 0.8, 0.4); const lM = new THREE.MeshStandardMaterial({ color: 0x000080 });
            const l1 = new THREE.Mesh(lG, lM); l1.position.set(-0.3, 0.4, 0); g.add(l1);
            const l2 = new THREE.Mesh(lG, lM); l2.position.set(0.3, 0.4, 0); g.add(l2);

            const fG = new THREE.BoxGeometry(0.4, 0.2, 0.6); const fM = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
            const f1 = new THREE.Mesh(fG, fM); f1.position.set(-0.3, 0.1, 0.1); g.add(f1);
            const f2 = new THREE.Mesh(fG, fM); f2.position.set(0.3, 0.1, 0.1); g.add(f2);

            g.scale.set(3, 3, 3);

            let pos = getRandomPos();
            if (pos) {
                g.position.set(pos.x, 0, -40); scene.add(g);
                enemies.push({ mesh: g, type: 'evil_dave', hp: 2, x: pos.x, z: -40, cooldown: 0 });
            }
        }

        function spawnGiantFriend() {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.5, 0.8), new THREE.MeshStandardMaterial({ color: 0x333333 })); b.position.y = 1.5; g.add(b);
            const h = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 12), new THREE.MeshStandardMaterial({ color: 0x33FF33 })); h.position.y = 2.6; g.add(h);

            const armG = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const armM = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const lA = new THREE.Mesh(armG, armM); lA.position.set(-0.8, 1.8, 0); g.add(lA);
            const rA = new THREE.Mesh(armG, armM); rA.position.set(0.8, 1.8, 0); g.add(rA);

            const lG = new THREE.BoxGeometry(0.4, 0.8, 0.4); const lM = new THREE.MeshStandardMaterial({ color: 0x000080 });
            const l1 = new THREE.Mesh(lG, lM); l1.position.set(-0.3, 0.4, 0); g.add(l1);
            const l2 = new THREE.Mesh(lG, lM); l2.position.set(0.3, 0.4, 0); g.add(l2);

            const fG = new THREE.BoxGeometry(0.4, 0.2, 0.6); const fM = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
            const f1 = new THREE.Mesh(fG, fM); f1.position.set(-0.3, 0.1, 0.1); g.add(f1);
            const f2 = new THREE.Mesh(fG, fM); f2.position.set(0.3, 0.1, 0.1); g.add(f2);

            g.scale.set(3, 3, 3);

            let pos = getRandomPos();
            if (pos) {
                g.position.set(pos.x, 0, pos.z); scene.add(g);
                npcs.push({
                    mesh: g, name: "Giant Green Dave", isTarget: false, collected: false, x: pos.x, z: pos.z, radius: 4.5,
                    moveDir: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(), moveTimer: 2, speed: 12, isAlly: true, cooldown: 0
                });
            }
        }

        // --- Updates & Physics ---

        function animate() {
            requestAnimationFrame(animate);

            if (gameState === 'TITLE') {
                if (playerMesh) playerMesh.rotation.y += 0.02;
                renderer.render(scene, camera);
                return;
            }

            if (gameState !== 'PLAYING') {
                renderer.render(scene, camera);
                return;
            }

            const dt = clock.getDelta();

            // Player
            updatePlayer(dt);

            // Camera
            camera.position.x = playerMesh.position.x;
            camera.position.z = playerMesh.position.z + 14;
            camera.position.y = 12;
            camera.lookAt(playerMesh.position.x, playerMesh.position.y + 1, playerMesh.position.z);

            // Enemies
            updateEnemies(dt);

            // Civilians & Allies
            npcs.forEach(npc => {
                if (npc.collected) return;

                // ALLY LOGIC
                if (npc.isAlly) {
                    // Find closest enemy
                    let closest = null;
                    let minDst = 1000;
                    enemies.forEach(e => {
                        let d = npc.mesh.position.distanceTo(e.mesh.position);
                        if (d < minDst) { minDst = d; closest = e; }
                    });

                    if (closest && minDst < 40) {
                        // Chase
                        let dir = new THREE.Vector3().subVectors(closest.mesh.position, npc.mesh.position).normalize();
                        let nextX = npc.mesh.position.x + dir.x * npc.speed * dt;
                        let nextZ = npc.mesh.position.z + dir.z * npc.speed * dt;

                        // Giant pathfinding (ignore small obstacles mostly)
                        npc.mesh.position.x = nextX; npc.mesh.position.z = nextZ;
                        npc.mesh.lookAt(closest.mesh.position.x, npc.mesh.position.y, closest.mesh.position.z);

                        // Attack
                        if (minDst < 6) {
                            npc.cooldown -= dt;
                            if (npc.cooldown <= 0) {
                                closest.hp -= 1;
                                SoundManager.play('hit');
                                npc.cooldown = 1.0;
                                closest.mesh.position.addScaledVector(dir, 5);

                                // Visual bump
                                npc.mesh.position.y += 1;
                                setTimeout(() => npc.mesh.position.y = 0, 100);

                                if (closest.hp <= 0) {
                                    scene.remove(closest.mesh);
                                    closest.dead = true; // Mark for removal
                                    if (closest.type === 'evil_dave') showMessage("Green Dave Defeated Evil Dave!");
                                }
                            }
                        }
                        return;
                    }
                }

                // Normal Wander Logic
                npc.moveTimer -= dt;
                if (npc.moveTimer <= 0) { npc.moveDir.set(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(); npc.moveTimer = 2 + Math.random() * 3; }
                let nx = npc.mesh.position.x + npc.moveDir.x * npc.speed * dt;
                let nz = npc.mesh.position.z + npc.moveDir.z * npc.speed * dt;
                if (Math.abs(nx) < 60 && Math.abs(nz) < 60) {
                    npc.mesh.position.x = nx; npc.mesh.position.z = nz;
                    npc.mesh.lookAt(nx, npc.mesh.position.y, nz);
                    npc.x = nx; npc.z = nz;
                } else npc.moveDir.negate();
            });

            // Clean up dead enemies from array (important since Ally kills them outside updateEnemies loop)
            enemies = enemies.filter(e => !e.dead);

            // Coins
            coins.forEach(c => { c.mesh.rotation.y += 3 * dt; });

            // Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i]; p.life -= dt;
                p.mesh.position.addScaledVector(p.dir, p.speed * dt);

                const playerCenter = playerMesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                if (p.mesh.position.distanceTo(playerCenter) < 2) {
                    takeDamage("Hit by " + p.type); scene.remove(p.mesh); projectiles.splice(i, 1);
                } else if (p.life <= 0) { scene.remove(p.mesh); projectiles.splice(i, 1); }
            }

            checkCollisions();
            renderer.render(scene, camera);
        }

        function shootProjectile(pos, target, type) {
            let mesh, speed;
            if (type === 'fireball') {
                mesh = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshBasicMaterial({ color: 0xFF4500 }));
                speed = CONFIG.fireballSpeed;
            } else {
                mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.5, 6), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
                mesh.rotation.x = Math.PI / 2;
                speed = CONFIG.arrowSpeed;
            }
            mesh.position.copy(pos);
            mesh.position.y += 2;
            scene.add(mesh);

            const dir = new THREE.Vector3().subVectors(target, pos).normalize();
            if (type === 'arrow') {
                mesh.lookAt(target);
                mesh.rotateX(Math.PI / 2);
            }

            projectiles.push({
                mesh: mesh,
                dir: dir,
                life: 2.0,
                type: type,
                speed: speed
            });
        }

        function updatePlayer(dt) {
            // Attack
            if (keys.attack && player.canAttack) {
                player.canAttack = false;
                SoundManager.play('attack');
                let start = Date.now();
                let int = setInterval(() => {
                    let e = Date.now() - start;
                    if (e > 200) { playerArmGroup.rotation.x = 0; clearInterval(int); setTimeout(() => player.canAttack = true, 500); return; }
                    playerArmGroup.rotation.x = -Math.PI / 2 * Math.sin((e / 200) * Math.PI);
                }, 16);

                // Hit check
                for (let i = enemies.length - 1; i >= 0; i--) {
                    let e = enemies[i];
                    if (playerMesh.position.distanceTo(e.mesh.position) < (e.type === 'evil_dave' ? 6 : 5)) {
                        let dir = new THREE.Vector3().subVectors(e.mesh.position, playerMesh.position).normalize();
                        let fwd = new THREE.Vector3(0, 0, 1).applyQuaternion(playerMesh.quaternion);
                        if (dir.dot(fwd) > 0.5) {
                            e.hp--;
                            SoundManager.play('hit');
                            e.mesh.position.addScaledVector(dir, 2); // Knockback
                            // Flash effect
                            e.mesh.children.forEach(c => {
                                if (c.material && c.material.emissive) {
                                    let old = c.material.emissive.getHex();
                                    c.material.emissive.setHex(0xff0000);
                                    setTimeout(() => c.material.emissive.setHex(old), 100);
                                }
                            });

                            if (e.hp <= 0) {
                                scene.remove(e.mesh);
                                e.dead = true; // Mark for removal
                                if (e.type === 'evil_dave') showMessage("You Defeated Evil Dave!");
                            }
                        }
                    }
                }
                keys.attack = false;
            }

            // Move
            if (keys.shift) player.isCrouching = true; else player.isCrouching = false;
            if (player.onGround && keys.space) { player.velocity.y = CONFIG.jumpForce; player.onGround = false; SoundManager.play('jump'); }
            player.velocity.y -= CONFIG.gravity * dt;
            playerMesh.position.y += player.velocity.y * dt;
            if (playerMesh.position.y <= 0) { playerMesh.position.y = 0; player.velocity.y = 0; player.onGround = true; }

            let spd = CONFIG.playerSpeed * (player.isCrouching ? 0.5 : 1) * dt;
            let dx = 0, dz = 0;
            if (keys.w) dz -= 1; if (keys.s) dz += 1; if (keys.a) dx -= 1; if (keys.d) dx += 1;

            if (dx !== 0 || dz !== 0) {
                let v = new THREE.Vector3(dx, 0, dz).normalize();
                let nx = playerMesh.position.x + v.x * spd;
                if (canMove(nx, playerMesh.position.z)) playerMesh.position.x = nx;
                let nz = playerMesh.position.z + v.z * spd;
                if (canMove(playerMesh.position.x, nz)) playerMesh.position.z = nz;
                playerMesh.rotation.y = Math.atan2(v.x, v.z);
            }
        }

        function updateEnemies(dt) {
            enemies.forEach(e => {
                if (e.dead) return; // Skip dead enemies waiting for cleanup

                let dist = e.mesh.position.distanceTo(playerMesh.position);
                e.mesh.lookAt(playerMesh.position.x, e.mesh.position.y, playerMesh.position.z);

                if (e.type === 'evil_dave' || e.type === 'warrior') {
                    if (dist < CONFIG.chaseRange && dist > (e.type === 'evil_dave' ? 4 : 2)) {
                        let v = new THREE.Vector3().subVectors(playerMesh.position, e.mesh.position).normalize();
                        let spd = (e.type === 'evil_dave' ? CONFIG.evilDaveSpeed : CONFIG.warriorSpeed) * dt;
                        e.mesh.position.addScaledVector(v, spd);
                    }
                    if (dist < (e.type === 'evil_dave' ? 5 : 2.5)) {
                        e.cooldown -= dt;
                        if (e.cooldown <= 0) {
                            takeDamage(e.type === 'evil_dave' ? "SMASHED!" : "Slashed!");
                            e.cooldown = 1.5;
                            let v = new THREE.Vector3().subVectors(playerMesh.position, e.mesh.position).normalize();
                            playerMesh.position.addScaledVector(v, e.type === 'evil_dave' ? 8 : 3);
                        }
                    }
                } else {
                    if (dist < CONFIG.enemyRange) {
                        e.cooldown -= dt;
                        if (e.cooldown <= 0) {
                            shootProjectile(e.mesh.position, playerMesh.position, e.type === 'wizard' ? 'fireball' : 'arrow');
                            e.cooldown = 3;
                        }
                    }
                }
            });
        }

        function checkCollisions() {
            // NPC Collect
            if (gameMode === 'story') {
                npcs.forEach(n => {
                    let hitDist = n.radius ? n.radius : (n.isTarget ? 3.5 : 2.5);

                    if (!n.collected && playerMesh.position.distanceTo(n.mesh.position) < hitDist) {

                        if (n.isTarget) {
                            // Objective Collected
                            n.collected = true; scene.remove(n.mesh);
                            SoundManager.play('coin');
                            showMessage("Found " + n.name);
                            let key = n.name.toLowerCase().split(' ')[0]; // 'Red', 'Blue'
                            if (targetsFound[key] !== undefined) targetsFound[key] = true;
                            document.getElementById(`badge-${key}`).classList.add('found');
                            if (Object.values(targetsFound).every(Boolean)) endGame(true, "You saved everyone!");
                        } else {
                            // Physical Collision (Stranger or Coin Rush Target or Giant Friend)
                            const dir = new THREE.Vector3().subVectors(playerMesh.position, n.mesh.position).normalize();
                            playerMesh.position.addScaledVector(dir, 1.5); // Pushback
                            n.moveDir.negate(); // They turn away

                            if (!n.isTarget && !n.isAlly) showMessage(`Just a stranger (${n.name})`);
                        }
                    }
                });
            }

            // Coin Collect
            for (let i = coins.length - 1; i >= 0; i--) {
                if (playerMesh.position.distanceTo(coins[i].mesh.position) < 2) {
                    scene.remove(coins[i].mesh);
                    coins.splice(i, 1);
                    SoundManager.play('coin');
                    sessionCoins++;
                    document.getElementById('coin-display').textContent = `Coins: ${sessionCoins}`;
                }
            }
        }

        function canMove(x, z) {
            if (Math.abs(x) > 60 || Math.abs(z) > 60) return false;
            if ((Math.abs(z - CONFIG.riverZ1) < 7 || Math.abs(z - CONFIG.riverZ2) < 7) && Math.abs(x) > 4.5) return false;
            for (let o of obstacles) { if (Math.hypot(x - o.x, z - o.z) < o.radius + 0.5) return false; }
            return true;
        }

        function takeDamage(msg) {
            playerHealth--;
            SoundManager.play('hit');
            let s = ""; for (let i = 0; i < playerHealth; i++) s += "♥";
            document.getElementById('health-display').textContent = s;
            showMessage(msg);
            scene.background = new THREE.Color(0xff0000); setTimeout(() => scene.background = new THREE.Color(0x87CEEB), 100);
            if (playerHealth <= 0) endGame(false, "You died!");
        }

        function showMessage(t) {
            const m = document.getElementById('message-area');
            m.textContent = t; m.style.opacity = 1;
            clearTimeout(msgTimeout);
            msgTimeout = setTimeout(() => m.style.opacity = 0, 2000);
        }

        // --- Shop UI Logic ---
        function updateShopUI() {
            bankDisplay.textContent = `Total Coins: ${saveData.coins}`;
            const list = document.getElementById('shop-list');
            list.innerHTML = '';

            for (const cat in ITEMS) {
                const catDiv = document.createElement('div');
                catDiv.className = 'shop-category';
                catDiv.innerHTML = `<h3>${cat.toUpperCase()}</h3>`;
                const itemsDiv = document.createElement('div');
                itemsDiv.className = 'shop-items';

                ITEMS[cat].forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'shop-item';

                    // Check status
                    const isOwned = saveData.owned.includes(item.id);
                    const isEquipped = saveData.equipped[item.type] === item.id; // Correct type reference

                    if (isEquipped) el.classList.add('equipped');
                    if (!isOwned && item.price > 0) el.classList.add('locked');

                    el.innerHTML = `
                        <div>${item.name}</div>
                        <div class="price-tag">${isOwned ? (isEquipped ? 'EQUIPPED' : 'OWNED') : item.price + ' Coins'}</div>
                    `;

                    el.onclick = () => buyOrEquip(item);
                    itemsDiv.appendChild(el);
                });
                catDiv.appendChild(itemsDiv);
                list.appendChild(catDiv);
            }
        }

        function buyOrEquip(item) {
            // Identify type strictly
            let itemType = '';
            if (ITEMS.shirts.some(i => i.id === item.id)) itemType = 'shirt';
            else if (ITEMS.pants.some(i => i.id === item.id)) itemType = 'pants';
            else if (ITEMS.hats.some(i => i.id === item.id)) itemType = 'hat';
            else if (ITEMS.swords.some(i => i.id === item.id)) itemType = 'sword';

            if (saveData.owned.includes(item.id)) {
                // Equip
                saveData.equipped[itemType] = item.id;
                renderTitleBackground(); // Re-render title player to show change
            } else {
                // Buy
                if (saveData.coins >= item.price) {
                    saveData.coins -= item.price;
                    saveData.owned.push(item.id);
                    saveData.equipped[itemType] = item.id; // Auto equip
                    renderTitleBackground();
                } else {
                    alert("Not enough coins!");
                }
            }
            saveGame();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>

</html>