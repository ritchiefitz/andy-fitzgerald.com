<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Escape Road: City Chaos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Vt323&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: #60a5fa;
            font-family: 'Vt323', monospace;
        }

        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #facc15;
            border-radius: 8px;
            padding: 10px 20px;
            color: #fff;
            text-transform: uppercase;
            transform: skew(-5deg);
            box-shadow: 5px 5px 0 rgba(0, 0, 0, 0.5);
        }

        .score-big {
            font-size: 32px;
            color: #facc15;
            text-shadow: 2px 2px #000;
        }

        .wanted-stars {
            color: #ef4444;
            font-size: 24px;
            letter-spacing: 5px;
        }

        #action-msg {
            position: absolute;
            bottom: 25%;
            left: 50%;
            transform: translateX(-50%);
            background: #facc15;
            color: #000;
            padding: 15px 30px;
            font-family: 'Black Ops One', cursive;
            font-size: 24px;
            border: 4px solid #000;
            display: none;
            animation: bounce 0.5s infinite alternate;
            text-align: center;
            white-space: nowrap;
            z-index: 10;
        }

        #health-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: #333;
            border: 2px solid #fff;
            skew: -10deg;
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background: #ef4444;
            transition: width 0.1s;
        }

        @keyframes bounce {
            from {
                transform: translateX(-50%) translateY(0);
            }

            to {
                transform: translateX(-50%) translateY(-10px);
            }
        }

        #start-screen,
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 20;
        }

        .title {
            font-family: 'Black Ops One', cursive;
            font-size: 80px;
            color: #facc15;
            text-shadow: 6px 6px 0 #b45309;
            margin-bottom: 10px;
            text-align: center;
            line-height: 0.9;
        }

        .subtitle {
            font-size: 30px;
            color: #fff;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }

        .btn {
            background: #ef4444;
            color: #fff;
            font-family: 'Black Ops One', cursive;
            font-size: 30px;
            padding: 15px 50px;
            border: none;
            border-bottom: 8px solid #991b1b;
            cursor: pointer;
            transition: all 0.1s;
            text-transform: uppercase;
        }

        .btn:active {
            transform: translateY(4px);
            border-bottom: 4px solid #991b1b;
        }

        .hidden {
            display: none !important;
        }

        /* Mobile Controls */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: auto;
            opacity: 0.7;
        }

        .m-btn {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border: 4px solid #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 30px;
            user-select: none;
        }

        .m-btn:active {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>

<body>

    <div id="game-ui">
        <div id="health-container">
            <div id="health-bar"></div>
        </div>
        <div class="flex justify-between w-full">
            <div class="hud-panel">
                <div class="text-sm text-gray-300">STOLEN CASH</div>
                <div class="score-big">$<span id="score">0</span></div>
            </div>
            <div class="hud-panel text-right">
                <div class="text-sm text-gray-300">WANTED</div>
                <div class="wanted-stars" id="wanted">★☆☆☆☆</div>
            </div>
        </div>
        <div id="action-msg">PRESS SPACE TO HIJACK</div>

        <div class="mobile-controls md:hidden">
            <div class="m-btn" id="btn-left">◄</div>
            <div class="m-btn" id="btn-action">⚡</div>
            <div class="m-btn" id="btn-right">►</div>
        </div>
    </div>

    <div id="start-screen">
        <div class="title">ESCAPE<br><span class="text-white text-6xl">PRISON RUN</span></div>
        <div class="subtitle">RUN. DRIVE. SURVIVE.</div>
        <button class="btn" onclick="startGame()">START ESCAPE</button>
    </div>

    <div id="game-over" class="hidden">
        <div class="title" style="color: #ef4444;">BUSTED</div>
        <div class="subtitle">CASH SECURED: $<span id="final-score">0</span></div>
        <button class="btn" onclick="startGame()">TRY AGAIN</button>
    </div>

    <script>
        /**
         * ESCAPE ROAD: PRISON RUN
         */

        // Config
        const CHUNK_SIZE = 300;
        const COLORS = {
            sky: 0x3b82f6,
            grass: 0x22c55e,
            road: 0x334155,
            buildings: [0xfca5a5, 0xfcd34d, 0x86efac, 0x93c5fd, 0xc4b5fd],
            skin: 0xffdbac,
            suit: 0xf97316,
            police: 0x1e3a8a
        };

        // Global State
        let scene, camera, renderer, clock;
        let gameState = 'MENU';
        let score = 0;
        let wantedLevel = 1;
        let player = null;
        let entities = [];
        let cops = [];
        let bullets = [];
        let props = [];
        let obstacles = [];
        let particles = [];
        let chunks = {};
        let screenShake = 0;

        // Inputs
        const keys = { left: false, right: false, down: false, space: false };

        // Audio Manager
        class SoundManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.05; // Reduced from 0.3 to 0.05 (Whole lot quieter)
                this.master.connect(this.ctx.destination);

                this.engineOsc = null;
                this.engineGain = null;
                this.engineFilter = null;
                this.sirenOsc = null;
                this.sirenGain = null;
            }

            init() {
                if (this.ctx.state === 'suspended') this.ctx.resume();

                // Engine rumble (Improved)
                this.engineOsc = this.ctx.createOscillator();
                this.engineOsc.type = 'sawtooth';
                this.engineOsc.frequency.value = 40;

                // Add Low Pass Filter to mufffle the harshness
                this.engineFilter = this.ctx.createBiquadFilter();
                this.engineFilter.type = 'lowpass';
                this.engineFilter.frequency.value = 100;

                this.engineGain = this.ctx.createGain();
                this.engineGain.gain.value = 0;

                // Chain: Osc -> Filter -> Gain -> Master
                this.engineOsc.connect(this.engineFilter);
                this.engineFilter.connect(this.engineGain);
                this.engineGain.connect(this.master);
                this.engineOsc.start();

                // Siren (Background)
                this.sirenOsc = this.ctx.createOscillator();
                this.sirenOsc.type = 'square';
                this.sirenOsc.frequency.value = 800;
                this.sirenGain = this.ctx.createGain();
                this.sirenGain.gain.value = 0;
                this.sirenOsc.connect(this.sirenGain);
                this.sirenGain.connect(this.master);
                this.sirenOsc.start();

                // LFO for Siren
                const lfo = this.ctx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 2;
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 200;
                lfo.connect(lfoGain);
                lfoGain.connect(this.sirenOsc.frequency);
                lfo.start();
            }

            updateEngine(speed) {
                if (!this.engineOsc) return;
                const absSpeed = Math.abs(speed);

                // Pitch rises with speed
                const targetFreq = 40 + absSpeed * 120;
                this.engineOsc.frequency.setTargetAtTime(targetFreq, this.ctx.currentTime, 0.1);

                // Filter opens up with speed
                const targetFilter = 100 + absSpeed * 800;
                this.engineFilter.frequency.setTargetAtTime(targetFilter, this.ctx.currentTime, 0.1);

                // Volume logic (Reduced mix)
                const vol = speed === 0 ? 0 : 0.1 + Math.min(absSpeed * 0.2, 0.2);
                this.engineGain.gain.setTargetAtTime(vol, this.ctx.currentTime, 0.1);
            }

            setSiren(active) {
                if (!this.sirenGain) return;
                // Reduced siren volume
                const vol = active ? 0.05 : 0;
                this.sirenGain.gain.setTargetAtTime(vol, this.ctx.currentTime, 0.5);
            }

            playShoot() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(this.master);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }

            playNoise(duration, vol = 0.5) {
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                noise.connect(gain);
                gain.connect(this.master);
                noise.start();
            }

            playCrash() {
                this.playNoise(0.3, 0.1); // Reduced volume from 0.3 to 0.1
            }

            playExplode() {
                this.playNoise(1.0, 0.6);
            }

            playDoor() {
                this.playNoise(0.1, 0.2);
            }
        }

        const audio = new SoundManager();

        // --- Setup ---

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.sky);
            scene.fog = new THREE.Fog(COLORS.sky, 100, 400);

            const aspect = window.innerWidth / window.innerHeight;
            const d = 35;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(100, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            scene.add(dirLight);

            const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
            rimLight.position.set(-50, 50, -50);
            scene.add(rimLight);

            clock = new THREE.Clock();

            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', e => handleKey(e, true));
            window.addEventListener('keyup', e => handleKey(e, false));
            setupTouch();

            animate();
        }

        // --- Classes ---

        class Entity {
            constructor(mesh) {
                this.mesh = mesh;
                this.dead = false;
                this.pos = mesh.position;
                scene.add(mesh);
            }
            remove() {
                if (!this.dead) {
                    this.dead = true;
                    scene.remove(this.mesh);
                }
            }
        }

        class Bullet extends Entity {
            constructor(x, z, angle, isEnemy) {
                const geo = new THREE.BoxGeometry(0.5, 0.5, 1.5);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, 3, z);
                mesh.rotation.y = angle;
                super(mesh);
                this.angle = angle;
                this.speed = 2.0;
                this.life = 60;
                this.isEnemy = isEnemy;
                audio.playShoot();
            }
            update() {
                this.pos.x += Math.sin(this.angle) * this.speed;
                this.pos.z += Math.cos(this.angle) * this.speed;
                this.life--;
                if (this.life <= 0) this.remove();

                // Collisions
                if (this.isEnemy) {
                    // Hit Player
                    if (player && !player.inCar && this.pos.distanceTo(player.pos) < 2) {
                        player.takeDamage(10);
                        this.remove();
                        audio.playCrash();
                        createExplosion(this.pos, 0.5, 0xff0000);
                    }
                    // Hit Player Car
                    if (player && player.inCar && player.currentCar && this.pos.distanceTo(player.currentCar.pos) < 4) {
                        player.currentCar.health -= 2;
                        this.remove();
                        audio.playCrash();
                        createParticle(this.pos.x, this.pos.y, this.pos.z, 0xcccccc, 0.5);
                    }
                }

                // Hit Buildings
                for (let b of obstacles) {
                    if (Math.abs(this.pos.x - b.x) < b.w / 2 && Math.abs(this.pos.z - b.z) < b.h / 2) {
                        this.remove();
                        createParticle(this.pos.x, this.pos.y, this.pos.z, 0xcccccc, 0.2);
                    }
                }
            }
        }

        class PoliceBot extends Entity {
            constructor(x, z) {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: COLORS.police });
                const skin = new THREE.MeshLambertMaterial({ color: COLORS.skin });
                const black = new THREE.MeshLambertMaterial({ color: 0x111111 });

                const head = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), skin);
                head.position.y = 4.2;
                group.add(head);
                const hat = new THREE.Mesh(new THREE.BoxGeometry(1.7, 0.5, 1.9), mat);
                hat.position.y = 5.0;
                group.add(hat);

                const body = new THREE.Mesh(new THREE.BoxGeometry(2.0, 2.5, 1.2), mat);
                body.position.y = 2.2;
                group.add(body);

                const armR = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.2, 0.6), mat);
                armR.position.set(1.4, 2.5, 0.5);
                armR.rotation.x = -Math.PI / 2;
                group.add(armR);
                const gun = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 1.5), black);
                gun.position.set(0, -1.2, 0.5);
                armR.add(gun);

                const armL = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.2, 0.6), mat);
                armL.position.set(-1.4, 2.5, 0);
                group.add(armL);

                group.position.set(x, 0, z);
                group.castShadow = true;
                super(group);

                this.cooldown = 0;
            }

            update(dt) {
                if (!player) return;

                const target = player.inCar && player.currentCar ? player.currentCar.pos : player.pos;
                const dist = this.pos.distanceTo(target);

                if (dist < 60) {
                    this.mesh.lookAt(target.x, this.pos.y, target.z);

                    if (dist > 15) {
                        const speed = 0.25;
                        this.pos.x += Math.sin(this.mesh.rotation.y) * speed;
                        this.pos.z += Math.cos(this.mesh.rotation.y) * speed;
                    } else {
                        if (this.cooldown <= 0) {
                            const bullet = new Bullet(this.pos.x, this.pos.z, this.mesh.rotation.y, true);
                            bullets.push(bullet);
                            this.cooldown = 60;
                        }
                    }
                }
                if (this.cooldown > 0) this.cooldown--;
                this.pos.y = 0;
            }
        }

        class Car extends Entity {
            constructor(x, z, isPolice = false) {
                const group = new THREE.Group();
                const color = isPolice ? 0x1e293b : [0xd946ef, 0x22c55e, 0x3b82f6, 0xeab308][Math.floor(Math.random() * 4)];

                const chassis = new THREE.Mesh(new THREE.BoxGeometry(6.3, 2.25, 12), new THREE.MeshLambertMaterial({ color: color }));
                chassis.position.y = 1.8;
                chassis.castShadow = true;
                group.add(chassis);

                const cabin = new THREE.Mesh(new THREE.BoxGeometry(5.7, 1.8, 6), new THREE.MeshLambertMaterial({ color: 0x111827 }));
                cabin.position.set(0, 3.75, -0.75);
                group.add(cabin);

                const bumperF = new THREE.Mesh(new THREE.BoxGeometry(6.3, 0.75, 0.75), new THREE.MeshLambertMaterial({ color: 0x333333 }));
                bumperF.position.set(0, 1.5, 6); group.add(bumperF);
                const bumperR = new THREE.Mesh(new THREE.BoxGeometry(6.3, 0.75, 0.75), new THREE.MeshLambertMaterial({ color: 0x333333 }));
                bumperR.position.set(0, 1.5, -6); group.add(bumperR);

                const hlGeo = new THREE.BoxGeometry(1.0, 0.5, 0.2);
                const hlL = new THREE.Mesh(hlGeo, new THREE.MeshBasicMaterial({ color: 0xffffaa })); hlL.position.set(-2, 1.8, 6.1); group.add(hlL);
                const hlR = new THREE.Mesh(hlGeo, new THREE.MeshBasicMaterial({ color: 0xffffaa })); hlR.position.set(2, 1.8, 6.1); group.add(hlR);
                const tlL = new THREE.Mesh(hlGeo, new THREE.MeshBasicMaterial({ color: 0xff3333 })); tlL.position.set(-2, 1.8, -6.1); group.add(tlL);
                const tlR = new THREE.Mesh(hlGeo, new THREE.MeshBasicMaterial({ color: 0xff3333 })); tlR.position.set(2, 1.8, -6.1); group.add(tlR);

                const wMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
                const wGeo = new THREE.BoxGeometry(1.5, 1.5, 2.25);
                [[-3, 0.75, -3.75], [3, 0.75, -3.75], [-3, 0.75, 3.75], [3, 0.75, 3.75]].forEach(p => {
                    const w = new THREE.Mesh(wGeo, wMat);
                    w.position.set(...p);
                    group.add(w);
                });

                let siren = null;
                if (isPolice) {
                    siren = new THREE.Mesh(new THREE.BoxGeometry(3, 0.6, 0.6), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                    siren.position.set(0, 4.8, -0.75);
                    group.add(siren);
                }

                group.position.set(x, 0, z);
                super(group);

                this.isPolice = isPolice;
                if (isPolice) this.siren = siren;
                this.controlled = false;
                this.speed = 0;
                this.angle = 0;
                this.velocity = new THREE.Vector3();
                this.health = 100;
                this.bobTimer = Math.random();
                this.lock = false;
                this.deployed = false;
            }

            update(dt) {
                if (this.dead) return;
                if (this.health <= 0) {
                    if (!this.dead) {
                        audio.playExplode();
                        createExplosion(this.pos, 3);
                        this.remove();
                    }
                    return;
                }

                if (this.controlled) {
                    if (keys.down) this.speed -= 0.03;
                    else this.speed += 0.015;

                    if (Math.abs(this.speed) > 0.1) {
                        if (keys.left) this.angle += 0.06;
                        if (keys.right) this.angle -= 0.06;
                    }
                    if (keys.space && !this.lock) {
                        player.exitCar();
                        this.lock = true;
                        setTimeout(() => { if (this) this.lock = false; }, 500);
                    }
                } else {
                    this.speed *= 0.96;
                    if (this.isPolice) {
                        if (player && player.inCar && player.currentCar) {
                            const target = player.currentCar.pos;
                            if (this.pos.distanceTo(target) < 400) {
                                const angleTo = Math.atan2(target.x - this.pos.x, target.z - this.pos.z);
                                let diff = angleTo - this.angle;
                                while (diff > Math.PI) diff -= Math.PI * 2;
                                while (diff < -Math.PI) diff += Math.PI * 2;
                                this.angle += Math.sign(diff) * 0.04;
                                this.speed += 0.02;
                            }
                        } else if (player && !player.inCar && !this.deployed) {
                            const dist = this.pos.distanceTo(player.pos);
                            if (dist < 60) {
                                this.speed *= 0.8;
                                if (Math.abs(this.speed) < 0.1) {
                                    this.speed = 0;
                                    const cop = new PoliceBot(this.pos.x + 5, this.pos.z);
                                    cops.push(cop);
                                    this.deployed = true;
                                    this.isPolice = false;
                                }
                            } else {
                                const angleTo = Math.atan2(player.pos.x - this.pos.x, player.pos.z - this.pos.z);
                                let diff = angleTo - this.angle;
                                while (diff > Math.PI) diff -= Math.PI * 2;
                                while (diff < -Math.PI) diff += Math.PI * 2;
                                this.angle += Math.sign(diff) * 0.04;
                                this.speed += 0.02;
                            }
                        }

                        if (this.siren) {
                            if (Math.floor(Date.now() / 100) % 2) this.siren.material.color.setHex(0xff0000);
                            else this.siren.material.color.setHex(0x0000ff);
                        }
                    }
                }

                const max = this.isPolice ? 1.3 : 1.1;
                if (this.speed > max) this.speed = max;
                if (this.speed < -0.5) this.speed = -0.5;

                const drift = 0.92;
                const vx = Math.sin(this.angle) * this.speed;
                const vz = Math.cos(this.angle) * this.speed;

                this.velocity.x = this.velocity.x * drift + vx * (1 - drift);
                this.velocity.z = this.velocity.z * drift + vz * (1 - drift);

                this.pos.add(this.velocity);
                this.mesh.rotation.y = this.angle;

                this.bobTimer += dt * 15 * Math.abs(this.speed);
                this.mesh.children[0].position.y = 1.8 + Math.sin(this.bobTimer) * 0.1;

                if (this.controlled && Math.abs(this.speed) > 0.8 && (keys.left || keys.right)) {
                    if (Math.random() > 0.5) createParticle(this.pos.x, 0.5, this.pos.z, 0xaaaaaa, 0.3);
                }

                this.checkCollisions();
            }

            checkCollisions() {
                for (let b of obstacles) {
                    if (Math.abs(this.pos.x - b.x) < b.w / 2 + 3 && Math.abs(this.pos.z - b.z) < b.h / 2 + 3) {
                        this.speed *= -0.5;
                        this.pos.add(this.velocity.clone().multiplyScalar(-2));
                        this.health -= 2;
                        screenShake = 0.4;
                        audio.playCrash();
                        for (let i = 0; i < 5; i++) createParticle(this.pos.x, 1, this.pos.z, 0xcccccc, 0.5);
                    }
                }
                for (let e of entities) {
                    if (e !== this && e instanceof Car && this.pos.distanceTo(e.pos) < 8) {
                        const push = this.pos.clone().sub(e.pos).normalize().multiplyScalar(2.5);
                        this.pos.add(push);
                        this.speed *= 0.9;
                        e.speed *= 0.9;
                        if (this.controlled && Math.abs(this.speed) < 0.2) this.speed = 0.2;
                        audio.playCrash();
                        createExplosion(this.pos.clone().add(e.pos).multiplyScalar(0.5), 2);
                        this.health -= 2;
                    }
                }
            }
        }

        class Player extends Entity {
            constructor(x, z) {
                const group = new THREE.Group();
                const suitMat = new THREE.MeshLambertMaterial({ color: COLORS.suit });
                const skinMat = new THREE.MeshLambertMaterial({ color: COLORS.skin });
                const hairMat = new THREE.MeshLambertMaterial({ color: 0x3f2e00 });
                const blackMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
                const whiteMat = new THREE.MeshLambertMaterial({ color: 0xffffff });

                const headGroup = new THREE.Group();
                headGroup.position.y = 4.5;
                group.add(headGroup);
                const face = new THREE.Mesh(new THREE.BoxGeometry(2.2, 2.0, 2.2), skinMat);
                headGroup.add(face);
                const hairTop = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.5, 2.4), hairMat);
                hairTop.position.y = 1.1;
                headGroup.add(hairTop);
                const hairBack = new THREE.Mesh(new THREE.BoxGeometry(2.4, 1.6, 0.6), hairMat);
                hairBack.position.set(0, 0.2, -0.9);
                headGroup.add(hairBack);
                const eyeGeo = new THREE.BoxGeometry(0.3, 0.3, 0.1);
                const eyeL = new THREE.Mesh(eyeGeo, blackMat);
                eyeL.position.set(-0.5, 0.1, 1.15);
                headGroup.add(eyeL);
                const eyeR = new THREE.Mesh(eyeGeo, blackMat);
                eyeR.position.set(0.5, 0.1, 1.15);
                headGroup.add(eyeR);
                const browGeo = new THREE.BoxGeometry(0.5, 0.15, 0.1);
                const browL = new THREE.Mesh(browGeo, hairMat);
                browL.position.set(-0.5, 0.4, 1.15);
                browL.rotation.z = 0.1;
                headGroup.add(browL);
                const browR = new THREE.Mesh(browGeo, hairMat);
                browR.position.set(0.5, 0.4, 1.15);
                browR.rotation.z = -0.1;
                headGroup.add(browR);

                const body = new THREE.Mesh(new THREE.BoxGeometry(3.2, 2.5, 1.8), suitMat);
                body.position.y = 2.5;
                group.add(body);
                const badge = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.1), whiteMat);
                badge.position.set(0.8, 3.0, 0.95);
                group.add(badge);
                const zipper = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.5, 0.05), new THREE.MeshLambertMaterial({ color: 0xd97706 }));
                zipper.position.set(0, 2.5, 0.91);
                group.add(zipper);

                const legGeo = new THREE.BoxGeometry(1.3, 2.5, 1.3);
                const shoeGeo = new THREE.BoxGeometry(1.4, 0.6, 1.5);
                const legL = new THREE.Group();
                legL.position.set(-0.9, 1.2, 0);
                const lLegMesh = new THREE.Mesh(legGeo, suitMat);
                lLegMesh.position.y = -1.25;
                legL.add(lLegMesh);
                const lShoe = new THREE.Mesh(shoeGeo, blackMat);
                lShoe.position.set(0, -2.5, 0.1);
                legL.add(lShoe);
                group.add(legL);
                const legR = new THREE.Group();
                legR.position.set(0.9, 1.2, 0);
                const rLegMesh = new THREE.Mesh(legGeo, suitMat);
                rLegMesh.position.y = -1.25;
                legR.add(rLegMesh);
                const rShoe = new THREE.Mesh(shoeGeo, blackMat);
                rShoe.position.set(0, -2.5, 0.1);
                legR.add(rShoe);
                group.add(legR);

                const armGeo = new THREE.BoxGeometry(1.1, 2.2, 1.1);
                const armL = new THREE.Group();
                armL.position.set(-2.2, 3.5, 0);
                const lArmMesh = new THREE.Mesh(armGeo, suitMat);
                lArmMesh.position.y = -1.0;
                armL.add(lArmMesh);
                const lHand = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.0, 1.0), skinMat);
                lHand.position.y = -2.3;
                armL.add(lHand);
                group.add(armL);
                const armR = new THREE.Group();
                armR.position.set(2.2, 3.5, 0);
                const rArmMesh = new THREE.Mesh(armGeo, suitMat);
                rArmMesh.position.y = -1.0;
                armR.add(rArmMesh);
                const rHand = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.0, 1.0), skinMat);
                rHand.position.y = -2.3;
                armR.add(rHand);
                group.add(armR);

                group.position.set(x, 0, z);
                group.castShadow = true;
                super(group);

                const ringGeo = new THREE.RingGeometry(3, 4, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
                this.targetRing = new THREE.Mesh(ringGeo, ringMat);
                this.targetRing.rotation.x = -Math.PI / 2;
                this.targetRing.position.y = 0.2;
                this.targetRing.visible = false;
                scene.add(this.targetRing);

                const arrowGeo = new THREE.ConeGeometry(1.5, 3, 4);
                const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                this.targetArrow = new THREE.Mesh(arrowGeo, arrowMat);
                this.targetArrow.rotation.x = Math.PI;
                this.targetArrow.visible = false;
                scene.add(this.targetArrow);

                this.legL = legL; this.legR = legR;
                this.armL = armL; this.armR = armR;
                this.head = headGroup;

                this.inCar = false;
                this.currentCar = null;
                this.runSpeed = 0.7;
                this.animTime = 0;
                this.lock = false;
                this.health = 100;
            }

            update(dt) {
                if (this.health <= 0) {
                    gameState = 'GAMEOVER';
                    document.getElementById('final-score').innerText = score;
                    document.getElementById('game-over').classList.remove('hidden');
                    return;
                }
                document.getElementById('health-bar').style.width = this.health + "%";

                if (this.inCar) {
                    this.mesh.visible = false;
                    this.targetRing.visible = false;
                    this.targetArrow.visible = false;
                    if (this.currentCar) this.pos.copy(this.currentCar.pos);
                    return;
                }
                this.mesh.visible = true;

                let mx = 0, mz = 0;
                if (keys.left) mx = -1;
                if (keys.right) mx = 1;
                if (keys.down) mz = 1;
                else mz = -1;

                const speed = this.runSpeed;
                const nextX = this.pos.x + mx * speed;
                const nextZ = this.pos.z + mz * speed;

                let hit = false;
                for (let b of obstacles) {
                    if (Math.abs(nextX - b.x) < b.w / 2 + 1 && Math.abs(nextZ - b.z) < b.h / 2 + 1) hit = true;
                }
                if (!hit) {
                    this.pos.x = nextX;
                    this.pos.z = nextZ;
                }

                if (mx !== 0 || mz !== 0) {
                    this.mesh.rotation.y = Math.atan2(mx, mz);
                    this.animTime += dt * 15;
                    this.legL.rotation.x = Math.sin(this.animTime) * 0.8;
                    this.legR.rotation.x = -Math.sin(this.animTime) * 0.8;
                    this.armL.rotation.x = -Math.sin(this.animTime) * 0.8;
                    this.armR.rotation.x = Math.sin(this.animTime) * 0.8;
                    this.head.position.y = 4.5 + Math.abs(Math.sin(this.animTime * 2)) * 0.1;
                }

                let closest = null, dist = 80;
                for (let e of entities) {
                    if (e instanceof Car && !e.dead && this.pos.distanceTo(e.pos) < dist) {
                        closest = e; dist = this.pos.distanceTo(e.pos);
                    }
                }

                if (closest) {
                    this.targetRing.visible = true;
                    this.targetRing.position.set(closest.pos.x, 0.5, closest.pos.z);
                    this.targetRing.rotation.z += dt * 2;

                    this.targetArrow.visible = true;
                    this.targetArrow.position.set(closest.pos.x, 8 + Math.sin(Date.now() / 100) * 2, closest.pos.z);
                    this.targetArrow.rotation.y += dt;
                } else {
                    this.targetRing.visible = false;
                    this.targetArrow.visible = false;
                }

                if (closest && keys.space && !this.lock && !this.inCar) {
                    this.enterCar(closest);
                    this.lock = true;
                    setTimeout(() => this.lock = false, 500);
                }

                this.pos.y = 1;
            }

            takeDamage(amount) {
                this.health -= amount;
                screenShake = 0.5;
            }

            enterCar(car) {
                this.inCar = true;
                this.currentCar = car;
                car.controlled = true;
                car.lock = true;
                setTimeout(() => { if (car) car.lock = false; }, 500);
                car.speed = 0;
                car.velocity.set(0, 0, 0);
                this.targetRing.visible = false;
                this.targetArrow.visible = false;
                audio.playDoor();
                if (car.isPolice) {
                    score += 500;
                    wantedLevel = Math.min(5, wantedLevel + 1);
                }
            }

            exitCar() {
                if (!this.inCar) return;
                this.inCar = false;
                this.pos.copy(this.currentCar.pos);
                this.pos.x += 7;
                this.pos.y = 2;
                this.currentCar.speed = 0;
                this.currentCar.velocity.set(0, 0, 0);
                this.currentCar.controlled = false;
                this.currentCar = null;
                audio.playDoor();
                this.lock = true;
                setTimeout(() => this.lock = false, 500);
            }
        }

        class Prop extends Entity {
            constructor(x, z) {
                const group = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.BoxGeometry(1.5, 6, 1.5), new THREE.MeshLambertMaterial({ color: COLORS.wood }));
                trunk.position.y = 3;
                group.add(trunk);
                const leaves = new THREE.Mesh(new THREE.BoxGeometry(4.5, 4.5, 4.5), new THREE.MeshLambertMaterial({ color: COLORS.tree }));
                leaves.position.y = 7.5;
                group.add(leaves);
                group.position.set(x, 0, z);
                super(group);
            }
        }

        function startGame() {
            audio.init();
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over').classList.add('hidden');

            entities.forEach(e => scene.remove(e.mesh));
            cops.forEach(c => scene.remove(c.mesh));
            bullets.forEach(b => scene.remove(b.mesh));
            props.forEach(p => scene.remove(p.mesh));

            entities = [];
            cops = [];
            bullets = [];
            props = [];
            obstacles = [];
            Object.values(chunks).forEach(g => scene.remove(g));
            chunks = {};

            if (player) {
                if (player.targetRing) scene.remove(player.targetRing);
                if (player.targetArrow) scene.remove(player.targetArrow);
                player.remove();
            }

            player = new Player(0, 0);
            const car = new Car(0, 0);
            entities.push(player);
            entities.push(car);
            player.enterCar(car);

            score = 0;
            wantedLevel = 1;
            gameState = 'PLAYING';
        }

        function generateChunk(cx, cz) {
            const group = new THREE.Group();

            const ground = new THREE.Mesh(new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE), new THREE.MeshLambertMaterial({ color: COLORS.grass }));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            group.add(ground);

            const roadMat = new THREE.MeshLambertMaterial({ color: COLORS.road });
            const markMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

            const roadH = new THREE.Mesh(new THREE.PlaneGeometry(CHUNK_SIZE, 40), roadMat);
            roadH.rotation.x = -Math.PI / 2; roadH.position.y = 0.1;
            group.add(roadH);
            for (let i = -5; i < 5; i++) {
                const dash = new THREE.Mesh(new THREE.PlaneGeometry(10, 2), markMat);
                dash.rotation.x = -Math.PI / 2; dash.position.set(i * 30, 0.15, 0); group.add(dash);
            }

            const roadV = new THREE.Mesh(new THREE.PlaneGeometry(40, CHUNK_SIZE), roadMat);
            roadV.rotation.x = -Math.PI / 2; roadV.position.y = 0.11;
            group.add(roadV);
            for (let i = -5; i < 5; i++) {
                const dash = new THREE.Mesh(new THREE.PlaneGeometry(2, 10), markMat);
                dash.rotation.x = -Math.PI / 2; dash.position.set(0, 0.16, i * 30); group.add(dash);
            }

            const count = 6;
            for (let i = 0; i < count; i++) {
                const w = 20 + Math.random() * 30;
                const h = 30 + Math.random() * 50;
                const d = 20 + Math.random() * 30;
                let lx = (Math.random() - 0.5) * (CHUNK_SIZE - 60);
                let lz = (Math.random() - 0.5) * (CHUNK_SIZE - 60);
                if (Math.abs(lx) < 40 || Math.abs(lz) < 40) continue;

                const col = COLORS.buildings[Math.floor(Math.random() * COLORS.buildings.length)];
                const bMesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshLambertMaterial({ color: col }));
                bMesh.position.set(lx, h / 2, lz);
                bMesh.castShadow = true;
                group.add(bMesh);

                const winGeo = new THREE.BoxGeometry(2, 2, 1);
                const winMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
                for (let wy = 5; wy < h - 5; wy += 8) {
                    for (let wx = -w / 2 + 4; wx < w / 2 - 4; wx += 6) {
                        if (Math.random() > 0.3) {
                            const win = new THREE.Mesh(winGeo, winMat);
                            win.position.set(lx + wx, wy, lz + d / 2);
                            group.add(win);
                        }
                    }
                }

                obstacles.push({ x: cx * CHUNK_SIZE + lx, z: cz * CHUNK_SIZE + lz, w: w, h: d });
            }

            for (let i = 0; i < 5; i++) {
                let lx = (Math.random() - 0.5) * CHUNK_SIZE;
                let lz = (Math.random() - 0.5) * CHUNK_SIZE;
                if (Math.abs(lx) < 30 || Math.abs(lz) < 30) {
                    let prop = new Prop(cx * CHUNK_SIZE + lx, cz * CHUNK_SIZE + lz);
                    props.push(prop);
                }
            }

            group.position.set(cx * CHUNK_SIZE, 0, cz * CHUNK_SIZE);
            scene.add(group);
            chunks[`${cx},${cz}`] = group;
        }

        function updateWorld(pos) {
            const cx = Math.floor(pos.x / CHUNK_SIZE);
            const cz = Math.floor(pos.z / CHUNK_SIZE);
            for (let x = cx - 1; x <= cx + 1; x++) {
                for (let z = cz - 1; z <= cz + 1; z++) {
                    if (!chunks[`${x},${z}`]) generateChunk(x, z);
                }
            }
        }

        function createParticle(x, y, z, color, speed) {
            const p = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshBasicMaterial({ color: color }));
            p.position.set(x, y, z);
            const vel = new THREE.Vector3((Math.random() - 0.5) * speed, Math.random() * speed, (Math.random() - 0.5) * speed);
            scene.add(p);
            particles.push({ mesh: p, vel: vel, life: 1.0 });
        }

        function createExplosion(pos, scale, color) {
            for (let i = 0; i < 10 * scale; i++) {
                createParticle(pos.x, pos.y + 2, pos.z, color || 0xffaa00, 1);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            if (gameState === 'PLAYING' && player) {
                score++;
                if (score % 1000 === 0 && wantedLevel < 5) wantedLevel++;

                document.getElementById('score').innerText = score;
                document.getElementById('wanted').innerText = "★".repeat(wantedLevel) + "☆".repeat(5 - wantedLevel);

                const target = player.inCar && player.currentCar ? player.currentCar.pos : player.pos;

                updateWorld(target);

                const offset = new THREE.Vector3(50, 50, 50);
                if (screenShake > 0) {
                    offset.addScalar((Math.random() - 0.5) * screenShake * 20);
                    screenShake *= 0.9;
                    if (screenShake < 0.01) screenShake = 0;
                }
                camera.position.lerp(target.clone().add(offset), 0.1);
                camera.lookAt(target);

                entities = entities.filter(e => !e.dead);
                entities.forEach(e => { if (e.update) e.update(dt); });

                cops = cops.filter(c => !c.dead);
                cops.forEach(c => c.update(dt));

                bullets = bullets.filter(b => !b.dead);
                bullets.forEach(b => b.update(dt));

                player.update(dt);
                audio.updateEngine(player.inCar && player.currentCar ? player.currentCar.speed : 0);
                audio.setSiren(wantedLevel > 1);

                const msg = document.getElementById('action-msg');
                if (player.inCar) {
                    msg.innerText = "PRESS SPACE TO EJECT";
                    msg.style.display = 'block';
                } else {
                    let carNear = false;
                    for (let e of entities) {
                        if (e instanceof Car && !e.dead && player.pos.distanceTo(e.pos) < 80) carNear = true;
                    }
                    if (carNear) {
                        msg.innerText = "PRESS SPACE TO ENTER";
                        msg.style.display = 'block';
                    } else {
                        msg.style.display = 'none';
                    }
                }

                if (entities.length < 15 + wantedLevel * 4) {
                    if (Math.random() < 0.1) {
                        const angle = Math.random() * Math.PI * 2;
                        const d = 200;
                        const car = new Car(target.x + Math.cos(angle) * d, target.z + Math.sin(angle) * d, true);
                        entities.push(car);
                    }
                }

                for (let i = entities.length - 1; i >= 0; i--) {
                    if (entities[i].pos.distanceTo(target) > 400) {
                        entities[i].remove();
                        entities.splice(i, 1);
                    }
                }

                if (player.inCar && player.currentCar && player.currentCar.dead) {
                    gameState = 'GAMEOVER';
                    document.getElementById('final-score').innerText = score;
                    document.getElementById('game-over').classList.remove('hidden');
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.mesh.position.add(p.vel);
                p.vel.y -= 0.02;
                p.life -= 0.02;
                p.mesh.scale.setScalar(p.life);
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        function handleKey(e, down) {
            const k = e.key.toLowerCase();
            if (k === 'arrowleft' || k === 'a') keys.left = down;
            if (k === 'arrowright' || k === 'd') keys.right = down;
            if (k === 'arrowdown' || k === 's') keys.down = down;
            if (k === ' ' || e.code === 'Space') keys.space = down;
        }

        function setupTouch() {
            const bind = (id, k) => {
                const el = document.getElementById(id);
                el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[k] = true; });
                el.addEventListener('touchend', (e) => { e.preventDefault(); keys[k] = false; });
            };
            bind('btn-left', 'left');
            bind('btn-right', 'right');
            bind('btn-action', 'space');
        }

        function onResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 35;
            camera.left = -d * aspect; camera.right = d * aspect;
            camera.top = d; camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();

    </script>
</body>

</html>