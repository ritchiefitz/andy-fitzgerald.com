<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0'>
  
  <!-- Primary Meta Tags -->
  <title>Snake Legends - Classic Snake Game with Power-ups | Andy's Epic Gaming Zone</title>
  <meta name='title' content='Snake Legends - Classic Snake Game with Power-ups'>
  <meta name='description' content='Classic snake game with power-ups and epic boss battles! Grow your snake, avoid obstacles, and become a legend in this modern twist.'>
  <meta name='keywords' content='snake game, classic snake, snake legends, arcade game, retro game, power-ups, boss battles'>
  <meta name='robots' content='index, follow'>
  <meta name='language' content='English'>
  <meta name='author' content='Andy Fitzgerald'>
  
  <!-- Open Graph / Facebook -->
  <meta property='og:type' content='website'>
  <meta property='og:url' content='https://andy-fitzgerald.com/games/snake-legends.html'>
  <meta property='og:title' content='Snake Legends - Classic Snake Game with Power-ups'>
  <meta property='og:description' content='Classic snake game with power-ups and epic boss battles! Grow your snake, avoid obstacles, and become a legend in this modern twist.'>
  <meta property='og:image' content='https://andy-fitzgerald.com/images/andy_my529.png'>
  <meta property='og:site_name' content='Andy\'s Epic Gaming Zone'>
  
  <!-- Twitter -->
  <meta property='twitter:card' content='summary_large_image'>
  <meta property='twitter:url' content='https://andy-fitzgerald.com/games/snake-legends.html'>
  <meta property='twitter:title' content='Snake Legends - Classic Snake Game with Power-ups'>
  <meta property='twitter:description' content='Classic snake game with power-ups and epic boss battles! Grow your snake, avoid obstacles, and become a legend in this modern twist.'>
  <meta property='twitter:image' content='https://andy-fitzgerald.com/images/andy_my529.png'>
  
  <!-- Favicon -->
  <link rel='icon' type='image/png' href='/favicon.png'>
  <link rel='apple-touch-icon' href='/favicon.png'>
  
  <!-- Canonical URL -->
  <link rel='canonical' href='https://andy-fitzgerald.com/games/snake-legends.html'>
  
  <!-- Stylesheets -->
  <link rel='stylesheet' href='../css/styles.css'>
  
  <!-- Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Game",
    "name": "Snake Legends",
    "description": "Classic snake game with power-ups and epic boss battles! Grow your snake, avoid obstacles, and become a legend in this modern twist.",
    "url": "https://andy-fitzgerald.com/games/snake-legends.html",
    "genre": "Arcade",
    "gamePlatform": "Web Browser",
    "operatingSystem": "Any",
    "applicationCategory": "Game",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "author": {
      "@type": "Person",
      "name": "Andy Fitzgerald"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Andy's Epic Gaming Zone",
      "url": "https://andy-fitzgerald.com"
    },
    "isPartOf": {
      "@type": "WebSite",
      "name": "Andy's Epic Gaming Zone",
      "url": "https://andy-fitzgerald.com"
    }
  }
  </script>
</head>
<body>
  <a href="../index.html" class="back-button">üè† Back to Gaming Zone</a>
  
  <div class="game-header">
    <h1>üêç SNAKE LEGENDS üêç</h1>
  </div>
  
  <div class="main-wrapper">
    <!-- Left Sidebar -->
    <div class="sidebar">
      <img src="../images/andy_my529.png" alt="Andy's 529 Plan" class="sidebar-image">
      <a href="https://gift.my529.org/LPXR40" target="_blank" class="donate-link">Donate to Andy</a>
    </div>
    
    <div class="content-wrapper">
      <div class="game-container">
      <div class="game-info">
        <div class="info-item score">
          SCORE: <span id="score">0</span>
        </div>
        <div class="info-item length">
          LENGTH: <span id="length">1</span>
        </div>
        <div class="info-item level">
          LEVEL: <span id="level">1</span>
        </div>
        <div class="info-item speed">
          SPEED: <span id="speed">1</span>
        </div>
      </div>
      
      <canvas id="gameCanvas" class="game-canvas" width="800" height="600"></canvas>
      
      <div class="controls">
        <button class="game-button" onclick="startGame()">üêç START GAME</button>
        <button class="game-button" onclick="pauseGame()">‚è∏Ô∏è PAUSE</button>
        <button class="game-button" onclick="resetGame()">üîÑ RESET</button>
        <button class="game-button" onclick="showLeaderboard()">üèÜ LEADERBOARD</button>
      </div>
      
      <div class="instructions">
        <h3>üéÆ HOW TO PLAY</h3>
        <p><strong>ARROW KEYS</strong> or <strong>WASD</strong> to move the snake</p>
        <p>Eat the glowing food to grow longer! Don't hit walls or yourself! üçé</p>
      </div>
    </div>
    </div>
    
    <!-- Right Sidebar -->
    <div class="sidebar">
      <img src="../images/andy_my529.png" alt="Andy's 529 Plan" class="sidebar-image">
      <a href="https://gift.my529.org/LPXR40" target="_blank" class="donate-link">Donate to Andy</a>
    </div>
  </div>
  
  <div class="game-over" id="gameOver">
    <h2>GAME OVER</h2>
    <p>Final Score: <span id="finalScore">0</span></p>
    <p>Snake Length: <span id="finalLength">1</span></p>
    <button class="game-button" onclick="resetGame()">üîÑ PLAY AGAIN</button>
  </div>
  
  <div class="paused" id="pausedScreen">
    <h2>GAME PAUSED</h2>
    <p>Press SPACE or click PAUSE to continue</p>
  </div>
  
  <div class="leaderboard" id="leaderboard">
    <h2>üèÜ SNAKE LEGENDS LEADERBOARD üèÜ</h2>
    <div class="leaderboard-list" id="leaderboardList">
      <!-- Leaderboard entries will be populated here -->
    </div>
    <button class="game-button" onclick="hideLeaderboard()">‚úñÔ∏è CLOSE</button>
  </div>
  
  <div class="name-entry" id="nameEntry">
    <h2>üéâ NEW HIGH SCORE! üéâ</h2>
    <p>You made it to the top 10!</p>
    <p>Score: <span id="newScoreDisplay">0</span></p>
    <input type="text" id="playerName" placeholder="Enter your name" maxlength="15" autocomplete="off">
    <br>
    <button class="game-button" onclick="submitScore()">‚úÖ SUBMIT</button>
    <button class="game-button" onclick="skipScore()">‚è≠Ô∏è SKIP</button>
  </div>

  <script>
    // Game variables
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let gameState = 'menu'; // menu, playing, paused, gameOver
    let score = 0;
    let level = 1;
    let gameSpeed = 200; // milliseconds between moves
    
    // Grid settings
    const gridSize = 20;
    const tileCountX = Math.floor(canvas.width / gridSize);
    const tileCountY = Math.floor(canvas.height / gridSize);
    
    // Snake
    let snake = [
      {x: 10, y: 10}
    ];
    let dx = 0;
    let dy = 0;
    
    // Food
    let food = {
      x: 15,
      y: 15
    };
    
    // Special food types
    let specialFood = null;
    let specialFoodTimer = 0;
    
    // Particles for effects
    let particles = [];
    
    // Game loop
    let gameLoop;
    let lastUpdateTime = 0;
    
    // Leaderboard system
    let leaderboard = [];
    let newScoreIndex = -1;
    
    // Load leaderboard from localStorage
    function loadLeaderboard() {
      const saved = localStorage.getItem('snakeLegendsLeaderboard');
      if (saved) {
        leaderboard = JSON.parse(saved);
      } else {
        // Initialize with default scores
        leaderboard = [
          {name: 'SNAKE MASTER', score: 500, length: 51},
          {name: 'PYTHON PRO', score: 400, length: 41},
          {name: 'VIPER KING', score: 300, length: 31},
          {name: 'COBRA CHAMP', score: 250, length: 26},
          {name: 'SERPENT ACE', score: 200, length: 21},
          {name: 'REPTILE HERO', score: 150, length: 16},
          {name: 'SCALE LEGEND', score: 100, length: 11},
          {name: 'SLITHER STAR', score: 80, length: 9},
          {name: 'COIL ROOKIE', score: 60, length: 7},
          {name: 'HISS NEWBIE', score: 40, length: 5}
        ];
        saveLeaderboard();
      }
    }
    
    // Save leaderboard to localStorage
    function saveLeaderboard() {
      localStorage.setItem('snakeLegendsLeaderboard', JSON.stringify(leaderboard));
    }
    
    // Check if score qualifies for leaderboard
    function isHighScore(score) {
      return leaderboard.length < 10 || score > leaderboard[leaderboard.length - 1].score;
    }
    
    // Add score to leaderboard
    function addToLeaderboard(name, score, length) {
      const entry = {name: name.toUpperCase(), score: score, length: length};
      leaderboard.push(entry);
      leaderboard.sort((a, b) => b.score - a.score);
      
      // Keep only top 10
      if (leaderboard.length > 10) {
        leaderboard = leaderboard.slice(0, 10);
      }
      
      // Find the new score's position
      newScoreIndex = leaderboard.findIndex(e => e.name === entry.name && e.score === entry.score && e.length === entry.length);
      
      saveLeaderboard();
    }
    
    // Initialize game
    function init() {
      resetSnake();
      generateFood();
      draw();
    }
    
    // Reset snake to starting position
    function resetSnake() {
      snake = [{x: 10, y: 10}];
      dx = 0;
      dy = 0;
    }
    
    // Generate regular food - GUARANTEED to appear
    function generateFood() {
      // Create list of all possible positions
      let availablePositions = [];
      
      for (let x = 0; x < tileCountX; x++) {
        for (let y = 0; y < tileCountY; y++) {
          if (!isPositionOccupied(x, y)) {
            availablePositions.push({x: x, y: y});
          }
        }
      }
      
      // If we have available positions, pick one randomly
      if (availablePositions.length > 0) {
        const randomIndex = Math.floor(Math.random() * availablePositions.length);
        food = availablePositions[randomIndex];
      } else {
        // Fallback - should never happen unless board is completely full
        food = {x: 0, y: 0};
        console.warn('No available positions for food!');
      }
    }
    
    // Check if a position is occupied by snake or special food
    function isPositionOccupied(x, y) {
      // Check snake segments
      for (let segment of snake) {
        if (segment.x === x && segment.y === y) {
          return true;
        }
      }
      
      // Check special food
      if (specialFood && specialFood.x === x && specialFood.y === y) {
        return true;
      }
      
      return false;
    }
    
    // Generate special food
    function generateSpecialFood() {
      if (Math.random() < 0.3 && !specialFood) {
        let attempts = 0;
        do {
          specialFood = {
            x: Math.floor(Math.random() * tileCountX),
            y: Math.floor(Math.random() * tileCountY),
            type: Math.random() < 0.5 ? 'bonus' : 'speed',
            timer: 300 // 5 seconds at 60fps
          };
          attempts++;
        } while (isSpecialFoodPositionOccupied(specialFood.x, specialFood.y) && attempts < 100);
        
        // If we couldn't find a valid position, don't create special food
        if (attempts >= 100) {
          specialFood = null;
        }
      }
    }
    
    // Check if special food position is occupied
    function isSpecialFoodPositionOccupied(x, y) {
      // Check snake segments
      for (let segment of snake) {
        if (segment.x === x && segment.y === y) {
          return true;
        }
      }
      
      // Check regular food
      if (food.x === x && food.y === y) {
        return true;
      }
      
      return false;
    }
    
    // Create particle effect
    function createParticles(x, y, color, count = 8) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x * gridSize + gridSize / 2,
          y: y * gridSize + gridSize / 2,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          life: 30,
          maxLife: 30,
          color: color,
          size: Math.random() * 4 + 2
        });
      }
    }
    
    // Input handling
    document.addEventListener('keydown', (e) => {
      if (gameState !== 'playing') {
        if (e.key === ' ') {
          e.preventDefault();
          if (gameState === 'paused') {
            pauseGame();
          }
        }
        return;
      }
      
      // Prevent reverse direction
      switch (e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          e.preventDefault(); // Prevent page scrolling
          if (dy !== 1) {
            dx = 0;
            dy = -1;
          }
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          e.preventDefault(); // Prevent page scrolling
          if (dy !== -1) {
            dx = 0;
            dy = 1;
          }
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          e.preventDefault(); // Prevent page scrolling
          if (dx !== 1) {
            dx = -1;
            dy = 0;
          }
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          e.preventDefault(); // Prevent page scrolling
          if (dx !== -1) {
            dx = 1;
            dy = 0;
          }
          break;
        case ' ':
          e.preventDefault();
          pauseGame();
          break;
        case 'p':
        case 'P':
          pauseGame();
          break;
      }
    });
    
    // Update game state
    function update() {
      if (gameState !== 'playing') return;
      
      // Don't move if no direction is set
      if (dx === 0 && dy === 0) return;
      
      // Move snake head
      const head = {x: snake[0].x + dx, y: snake[0].y + dy};
      
      // Check wall collision
      if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) {
        gameOver();
        return;
      }
      
      // Check self collision
      for (let segment of snake) {
        if (head.x === segment.x && head.y === segment.y) {
          gameOver();
          return;
        }
      }
      
      snake.unshift(head);
      
      // Check food collision
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        createParticles(food.x, food.y, '#00ff41', 12);
        
        // ALWAYS generate new food immediately
        generateFood();
        
        // Increase speed with each food eaten
        gameSpeed = Math.max(50, gameSpeed - 5); // Faster acceleration per food, minimum 50ms
        
        // Check for level up (every 50 points) - just for display now
        if (score > 0 && score % 50 === 0) {
          level++;
        }
        
        // Generate special food occasionally
        generateSpecialFood();
      } else {
        // Remove tail if no food eaten
        snake.pop();
      }
      
      // Check special food collision
      if (specialFood && head.x === specialFood.x && head.y === specialFood.y) {
        if (specialFood.type === 'bonus') {
          score += 50;
          createParticles(specialFood.x, specialFood.y, '#ffaa00', 15);
        } else if (specialFood.type === 'speed') {
          score += 25;
          // Temporarily slow down the game
          gameSpeed += 30;
          setTimeout(() => {
            gameSpeed = Math.max(80, gameSpeed - 30);
          }, 5000);
          createParticles(specialFood.x, specialFood.y, '#4a90e2', 15);
        }
        specialFood = null;
      }
      
      // Update special food timer
      if (specialFood) {
        specialFood.timer--;
        if (specialFood.timer <= 0) {
          specialFood = null;
        }
      }
      
      // Update particles
      particles = particles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life--;
        particle.vx *= 0.98;
        particle.vy *= 0.98;
        return particle.life > 0;
      });
      
      updateUI();
    }
    
    // Draw everything
    function draw() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw grid (subtle)
      ctx.strokeStyle = 'rgba(0, 255, 65, 0.1)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= tileCountX; i++) {
        ctx.beginPath();
        ctx.moveTo(i * gridSize, 0);
        ctx.lineTo(i * gridSize, canvas.height);
        ctx.stroke();
      }
      for (let i = 0; i <= tileCountY; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * gridSize);
        ctx.lineTo(canvas.width, i * gridSize);
        ctx.stroke();
      }
      
      // Draw snake
      snake.forEach((segment, index) => {
        if (index === 0) {
          // Snake head
          ctx.fillStyle = '#00ff41';
          ctx.shadowColor = '#00ff41';
          ctx.shadowBlur = 10;
        } else {
          // Snake body
          const alpha = Math.max(0.3, 1 - (index * 0.05));
          ctx.fillStyle = `rgba(0, 255, 65, ${alpha})`;
          ctx.shadowBlur = 5;
        }
        
        ctx.fillRect(
          segment.x * gridSize + 2,
          segment.y * gridSize + 2,
          gridSize - 4,
          gridSize - 4
        );
        
        // Add snake head details
        if (index === 0) {
          ctx.fillStyle = '#ffffff';
          ctx.shadowBlur = 0;
          // Eyes
          ctx.fillRect(segment.x * gridSize + 6, segment.y * gridSize + 6, 3, 3);
          ctx.fillRect(segment.x * gridSize + 11, segment.y * gridSize + 6, 3, 3);
        }
      });
      
      ctx.shadowBlur = 0;
      
      // Draw regular food
      if (food) {
        ctx.fillStyle = '#ff6b35';
        ctx.shadowColor = '#ff6b35';
        ctx.shadowBlur = 15;
        ctx.fillRect(
          food.x * gridSize + 3,
          food.y * gridSize + 3,
          gridSize - 6,
          gridSize - 6
        );
        ctx.shadowBlur = 0;
      }
      
      // Draw special food
      if (specialFood) {
        const pulseAlpha = 0.5 + 0.5 * Math.sin(Date.now() * 0.01);
        if (specialFood.type === 'bonus') {
          ctx.fillStyle = `rgba(255, 170, 0, ${pulseAlpha})`;
          ctx.shadowColor = '#ffaa00';
        } else {
          ctx.fillStyle = `rgba(74, 144, 226, ${pulseAlpha})`;
          ctx.shadowColor = '#4a90e2';
        }
        ctx.shadowBlur = 20;
        ctx.fillRect(
          specialFood.x * gridSize + 1,
          specialFood.y * gridSize + 1,
          gridSize - 2,
          gridSize - 2
        );
        ctx.shadowBlur = 0;
      }
      
      // Draw particles
      particles.forEach(particle => {
        const alpha = particle.life / particle.maxLife;
        ctx.fillStyle = particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
        ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
      });
      
      // Draw game over screen
      if (gameState === 'gameOver') {
        document.getElementById('gameOver').style.display = 'block';
        document.getElementById('finalScore').textContent = score;
        document.getElementById('finalLength').textContent = snake.length;
      } else {
        document.getElementById('gameOver').style.display = 'none';
      }
      
      // Draw pause screen
      if (gameState === 'paused') {
        document.getElementById('pausedScreen').style.display = 'block';
      } else {
        document.getElementById('pausedScreen').style.display = 'none';
      }
    }
    
    // Game functions
    function startGame() {
      gameState = 'playing';
      score = 0;
      level = 1;
      gameSpeed = 200; // Good starting speed
      lastUpdateTime = Date.now();
      
      resetSnake();
      generateFood();
      specialFood = null;
      particles = [];
      
      updateUI();
      
      if (gameLoop) clearInterval(gameLoop);
      gameLoop = setInterval(() => {
        const currentTime = Date.now();
        if (currentTime - lastUpdateTime >= gameSpeed) {
          update();
          lastUpdateTime = currentTime;
        }
        draw();
      }, 16); // 60 FPS for smooth rendering
    }
    
    function pauseGame() {
      if (gameState === 'playing') {
        gameState = 'paused';
        clearInterval(gameLoop);
      } else if (gameState === 'paused') {
        gameState = 'playing';
        lastUpdateTime = Date.now(); // Reset timing when unpausing
        gameLoop = setInterval(() => {
          const currentTime = Date.now();
          if (currentTime - lastUpdateTime >= gameSpeed) {
            update();
            lastUpdateTime = currentTime;
          }
          draw();
        }, 16); // 60 FPS for smooth rendering
      }
    }
    
    function resetGame() {
      gameState = 'menu';
      if (gameLoop) clearInterval(gameLoop);
      startGame();
    }
    
    function gameOver() {
      gameState = 'gameOver';
      clearInterval(gameLoop);
      createParticles(snake[0].x, snake[0].y, '#ff6b35', 20);
      
      // Check if score qualifies for leaderboard
      if (isHighScore(score)) {
        showNameEntry();
      } else {
        // Show regular game over screen
        document.getElementById('gameOver').style.display = 'block';
        document.getElementById('finalScore').textContent = score;
        document.getElementById('finalLength').textContent = snake.length;
      }
    }
    
    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('length').textContent = snake.length;
      document.getElementById('level').textContent = level;
      const speedLevel = Math.max(1, Math.floor((200 - gameSpeed) / 20) + 1);
      document.getElementById('speed').textContent = speedLevel;
    }
    
    // Show leaderboard
    function showLeaderboard() {
      displayLeaderboard();
      document.getElementById('leaderboard').style.display = 'block';
    }
    
    // Hide leaderboard
    function hideLeaderboard() {
      document.getElementById('leaderboard').style.display = 'none';
      newScoreIndex = -1; // Reset highlight
    }
    
    // Display leaderboard entries
    function displayLeaderboard() {
      const listElement = document.getElementById('leaderboardList');
      listElement.innerHTML = '';
      
      if (leaderboard.length === 0) {
        listElement.innerHTML = '<p>No scores yet! Be the first to play!</p>';
        return;
      }
      
      leaderboard.forEach((entry, index) => {
        const entryDiv = document.createElement('div');
        entryDiv.className = 'leaderboard-entry';
        if (index === newScoreIndex) {
          entryDiv.className += ' new-score';
        }
        
        entryDiv.innerHTML = `
          <span><strong>#${index + 1}</strong> ${entry.name}</span>
          <span>${entry.score} pts (${entry.length} long)</span>
        `;
        
        listElement.appendChild(entryDiv);
      });
    }
    
    // Show name entry for high score
    function showNameEntry() {
      document.getElementById('newScoreDisplay').textContent = score;
      document.getElementById('playerName').value = '';
      document.getElementById('nameEntry').style.display = 'block';
      document.getElementById('playerName').focus();
    }
    
    // Submit score to leaderboard
    function submitScore() {
      const name = document.getElementById('playerName').value.trim();
      if (name === '') {
        alert('Please enter your name!');
        return;
      }
      
      addToLeaderboard(name, score, snake.length);
      document.getElementById('nameEntry').style.display = 'none';
      showLeaderboard();
    }
    
    // Skip adding score to leaderboard
    function skipScore() {
      document.getElementById('nameEntry').style.display = 'none';
      document.getElementById('gameOver').style.display = 'block';
    }
    
    // Handle Enter key in name input
    document.getElementById('playerName').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        submitScore();
      }
    });
    
    // Initialize game
    loadLeaderboard();
    init();
  </script>
</body>
</html>
